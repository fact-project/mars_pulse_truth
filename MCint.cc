//
// File generated by rootcint at Mon Nov 28 11:07:43 2016

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME MCint
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "MCint.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// Direct notice to TROOT of the dictionary's loading.
namespace {
   static struct DictInit {
      DictInit() {
         ROOT::RegisterModule();
      }
   } __TheDictionaryInitializer;
}

// START OF SHADOWS

namespace ROOTShadow {
   namespace Shadow {
      namespace FITS {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::FITS::Compression Compression;
      #else
      class Compression  {
         public:
         //friend XX;
         vector< uint16_t > sequence; //
         ::FITS::BlockHeader header; //
      };
      #endif
      } 
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::izstream izstream;
      #else
      class izstream  :  public ::basic_streambuf< char, ::char_traits< char >  >,  public ::basic_istream< char, ::char_traits< char >  > {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~izstream() throw() {};
         void* fFile; //file handle for compressed file
         char* fBuffer; //data buffer
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::Checksum Checksum;
      #else
      class Checksum  {
         public:
         //friend XX;
         unsigned long buffer; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::fits fits;
      #else
      class fits  :  public ::izstream {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::fits::Compression_t Compression_t;
         #else
         enum Compression_t  {
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::fits::fitsstate fitsstate;
         #else
         enum fitsstate  {
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::fits::Entry Entry;
         #else
         class Entry  {
            public:
            //friend XX;
            char type; //
            string value; //
            string comment; //
            string fitsString; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::fits::Table Table;
         #else
         class Table  {
            public:
            //friend XX;
            #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
            typedef ::fits::Table::Column Column;
            #else
            class Column  {
               public:
               //friend XX;
               unsigned long offset; //
               unsigned long num; //
               unsigned long size; //
               unsigned long bytes; //num*size
               char type; //
               string unit; //
               ::fits::Compression_t comp; //
            };
            #endif

            typedef ::std::map< ::string, ::fits::Entry, ::less< ::string>, ::allocator< ::pair<const  ::string,fits::Entry> > > Keys;
            typedef ::std::map< ::string, ::fits::Table::Column, ::less< ::string>, ::allocator< ::pair<const  ::string,fits::Table::Column> > > Columns;
            typedef ::std::vector< ::fits::Table::Column, ::allocator< ::fits::Table::Column> > SortedColumns;
            unsigned long offset; //
            bool is_compressed; //
            string name; //
            unsigned long bytes_per_row; //
            unsigned long num_rows; //
            unsigned long num_cols; //
            unsigned long total_bytes; //NAXIS1*NAXIS2
            Columns cols; //
            SortedColumns sorted_cols; //
            Keys keys; //
            long datasum; //
         };
         #endif

         typedef ::pair<void*, ::fits::Table::Column> Address;
         typedef ::std::vector< ::pair<void*, ::fits::Table::Column>, ::allocator< ::pair<void*, ::fits::Table::Column> > > Addresses;
         typedef ::unordered_map< ::string,void*> Pointers;
         // To force the creation of a virtual table, throw just in case.
         virtual ~fits() throw() {};
         ::basic_ofstream< char, ::char_traits< char >  > fCopy; //
         vector< ::string > fListOfTables; //List of skipped tables. Last table is open table
         Table fTable; //
         Addresses fAddresses; //
         ::unordered_map< ::string, void* > fPointers; //
         vector< vector< char, allocator< char >  >  > fGarbage; //
         vector< char > fBufferRow; //
         vector< char > fBufferDat; //
         unsigned long fRow; //
         ::Checksum fChkHeader; //
         ::Checksum fChkData; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ofits ofits;
      #else
      class ofits  :  public ::basic_ostream< char, ::char_traits< char >  > {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ofits::Key Key;
         #else
         class Key  {
            public:
            //friend XX;
            string key; //
            bool delim; //
            string value; //
            string comment; //
            string fitsString; //
            unsigned long offset; //offset in file
            bool changed; //For closing the file
            ::Checksum checksum; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ofits::Table Table;
         #else
         class Table  {
            public:
            //friend XX;
            #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
            typedef ::ofits::Table::Column Column;
            #else
            class Column  {
               public:
               //friend XX;
               string name; //
               unsigned long offset; //
               unsigned long num; //
               unsigned long size; //
               char type; //
            };
            #endif

            unsigned long offset; //
            unsigned long bytes_per_row; //
            unsigned long num_rows; //
            unsigned long num_cols; //
            vector< Column > cols; //
         };
         #endif

         // To force the creation of a virtual table, throw just in case.
         virtual ~ofits() throw() {};
         ::basic_filebuf< char, ::char_traits< char >  > fFilebuf; //
         vector< Key > fKeys; //
         Table fTable; //
         vector< char > fOutputBuffer; //
         ::Checksum fDataSum; //
         ::Checksum fHeaderSum; //
         bool fCommentTrimming; //
         bool fManualExtName; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::zofits zofits;
      #else
      class zofits  :  public ::ofits {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::zofits::CatalogEntry CatalogEntry;
         #else
         class CatalogEntry  {
            public:
            //friend XX;
            char dummy[16]; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::zofits::WriteTarget WriteTarget;
         #else
         class WriteTarget  {
            public:
            //friend XX;
            unsigned int tile_num; ///< Tile index of the data (to make sure that they are written in the correct order)
            unsigned int size; ///< Size to write
            ::shared_ptr< char > data; ///< Memory block to write
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::zofits::CompressionTarget CompressionTarget;
         #else
         class CompressionTarget  {
            public:
            //friend XX;
            ::zofits::CatalogRow* catalog_entry; ///< Reference to the catalog entry to deal with
            ::shared_ptr< char > src; ///< Original data
            ::shared_ptr< char > transposed_src; ///< Transposed data
            ::zofits::WriteTarget target; ///< Compressed data
            unsigned int num_rows; ///< Number of rows to compress
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::zofits::QueueMin< ::zofits::WriteTarget > QueueMinlEzofitscLcLWriteTargetgR;
         #else
         class QueueMinlEzofitscLcLWriteTargetgR  :  public list< ::zofits::WriteTarget, allocator< ::zofits::WriteTarget >  > {
            public:
            //friend XX;
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::zofits::CompressedColumn CompressedColumn;
         #else
         class CompressedColumn  {
            public:
            //friend XX;
            ::ofits::Table::Column col; ///< the regular column entry
            ::FITS::Compression block_head; ///< the compression data associated with that column
         };
         #endif

         typedef ::std::vector< ::zofits::CatalogEntry, ::allocator< ::zofits::CatalogEntry> > CatalogRow;
         typedef ::std::list< ::vector< ::zofits::CatalogEntry, ::allocator< ::zofits::CatalogEntry> >, ::allocator< ::vector< ::zofits::CatalogEntry, ::allocator< ::zofits::CatalogEntry> > > > CatalogType;
         // To force the creation of a virtual table, throw just in case.
         virtual ~zofits() throw() {};
         ::MemoryManager fMemPool; ///< Actual memory manager, providing memory for the compression buffers
         int fNumQueues; ///< Current number of threads that will be used by this object
         unsigned long fMaxUsableMem; ///< Maximum number of bytes that can be allocated by the memory manager
         int fLatestWrittenTile; ///< Index of the last tile written to disk (for correct ordering while using several threads)
         vector< ::Queue< ::zofits::CompressionTarget, list< ::zofits::CompressionTarget, allocator< ::zofits::CompressionTarget >  >  >  > fCompressionQueues; ///< Processing queues (=threads)
         ::Queue< ::zofits::WriteTarget, ::zofits::QueueMin< ::zofits::WriteTarget >  > fWriteToDiskQueue; ///< Writing queue (=thread)
         CatalogType fCatalog; ///< Catalog for this file
         unsigned int fCatalogSize; ///< Actual catalog size (.size() is slow on large lists)
         unsigned int fNumTiles; ///< Number of pre-reserved tiles
         unsigned int fNumRowsPerTile; ///< Number of rows per tile
         unsigned long fCatalogOffset; ///< Offset of the catalog from the beginning of the file
         ::Checksum fCatalogSum; ///< Checksum of the catalog
         ::Checksum fRawSum; ///< Raw sum (specific to FACT)
         int fCheckOffset; ///< offset to the data pointer to calculate the checksum
         vector< CompressedColumn > fRealColumns; ///< Vector hosting the columns of the file
         unsigned int fRealRowWidth; ///< Width in bytes of one uncompressed row
         ::shared_ptr< char > fSmartBuffer; ///< Smart pointer to the buffer where the incoming rows are written
         vector< char > fRawSumBuffer; ///< buffer used for checksuming the incoming data, before compression
         void* fThreadsException; ///< exception pointer to store exceptions coming from the threads
         int fErrno; ///< propagate errno to main thread
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::DrsCalibrateTime DrsCalibrateTime;
      #else
      class DrsCalibrateTime  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~DrsCalibrateTime() throw() {};
         long fNumEntries; //
         unsigned long fNumSamples; //
         unsigned long fNumChannels; //
         vector< pair< double, double >  > fStat; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::factofits factofits;
      #else
      class factofits  :  public ::zofits {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~factofits() throw() {};
         vector< int16_t > fOffsetCalibration; ///< The calibration itself
         int fStartCellsOffset; ///< Offset in bytes for the startcell data
         int fDataOffset; ///< Offset in bytes for the data
         int fNumSlices; ///< Number of samples per pixel per event
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::zfits zfits;
      #else
      class zfits  :  public ::fits {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~zfits() throw() {};
         bool fCatalogInitialized; //
         vector< char > fBuffer; ///<store the uncompressed rows
         vector< char > fTransposedBuffer; ///<intermediate buffer to transpose the rows
         vector< char > fCompressedBuffer; ///<compressed rows
         vector< char > fColumnOrdering; ///< ordering of the column's rows. Can change from tile to tile.
         unsigned long fNumTiles; ///< Total number of tiles
         unsigned long fNumRowsPerTile; ///< Number of rows per compressed tile
         long fCurrentRow; ///< current row in memory signed because we need -1
         unsigned long fShrinkFactor; ///< shrink factor
         G__int64 fHeapOff; ///< offset from the beginning of the file of the binary data
         G__int64 fHeapFromDataStart; ///< offset from the beginning of the data table
         vector< vector< pair< long, long >, allocator< pair< long, long >  >  >  > fCatalog; ///< Catalog, i.e. the main table that points to the compressed data.
         vector< size_t > fTileSize; ///< size in bytes of each compressed tile
         vector< vector< unsigned long, allocator< unsigned long >  >  > fTileOffsets; ///< offset from start of tile of a given compressed column
         ::Checksum fRawsum; ///< Checksum of the uncompressed, raw data
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::factfits factfits;
      #else
      class factfits  :  public ::zfits {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~factfits() throw() {};
         vector< int16_t > fOffsetCalibration; ///< integer values of the drs calibration used for compression
         unsigned long fOffsetStartCellData; //
         unsigned long fOffsetData; //
         unsigned short fNumRoi; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::PixelMapEntry PixelMapEntry;
      #else
      class PixelMapEntry  {
         public:
         //friend XX;
         int index; /// Software index
         int cbpx; /// Hardware index as CBPX
         int gapd; /// gAPD index
         int hv_board; /// Bias suppply board
         int hv_channel; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::PixelMap PixelMap;
      #else
      class PixelMap  :  public vector< ::PixelMapEntry, allocator< ::PixelMapEntry >  > {
         public:
         //friend XX;
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::BiasMapEntry BiasMapEntry;
      #else
      class BiasMapEntry  {
         public:
         //friend XX;
         int hv_board; /// Bias suppply board
         int hv_channel; /// Bias supply channel
         float Vnom; /// Channel bias voltage nominal
         float Voff; /// Channel bias voltage offset [V]
         float Vslope; /// Channel bias voltage slope  [Ohm]
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::BiasMap BiasMap;
      #else
      class BiasMap  :  public vector< ::BiasMapEntry, allocator< ::BiasMapEntry >  > {
         public:
         //friend XX;
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::Interpolator2D Interpolator2D;
      #else
      class Interpolator2D  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Interpolator2D::vec vec;
         #else
         class vec  {
            public:
            //friend XX;
            double x; //
            double y; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Interpolator2D::point point;
         #else
         class point  :  public ::Interpolator2D::vec {
            public:
            //friend XX;
            unsigned int i; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Interpolator2D::circle circle;
         #else
         class circle  :  public ::Interpolator2D::point {
            public:
            //friend XX;
            ::Interpolator2D::point p[3]; //
            double r; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Interpolator2D::weight weight;
         #else
         class weight  :  public ::Interpolator2D::point {
            public:
            //friend XX;
            ::Interpolator2D::circle c; //
            double w[3]; //
         };
         #endif

         vector< point > inputGrid; /// positions of the data points (e.g. sensors)
         vector< point > outputGrid; /// positions at which inter-/extrapolated values should be provided
         vector< circle > circles; /// the calculated circles/triangles
         vector< weight > weights; /// the weights used for the interpolation
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOTShadow
// END OF SHADOWS

namespace FITS {
   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void FITS_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("FITS", 0 /*version*/, "./mcore/FITS.h", 25,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &FITS_Dictionary, 4);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void FITS_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOTDict {
   void FITScLcLCompression_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FITScLcLCompression_Dictionary();
   static void *new_FITScLcLCompression(void *p = 0);
   static void *newArray_FITScLcLCompression(Long_t size, void *p);
   static void delete_FITScLcLCompression(void *p);
   static void deleteArray_FITScLcLCompression(void *p);
   static void destruct_FITScLcLCompression(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::FITS::Compression*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::FITS::Compression) == sizeof( ::ROOTShadow::Shadow::FITS::Compression));
      ::FITS::Compression *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FITS::Compression),0);
      static ::ROOT::TGenericClassInfo 
         instance("FITS::Compression", "./mcore/FITS.h", 147,
                  typeid(::FITS::Compression), ::ROOT::DefineBehavior(ptr, ptr),
                  &FITScLcLCompression_ShowMembers, &FITScLcLCompression_Dictionary, isa_proxy, 4,
                  sizeof(::FITS::Compression) );
      instance.SetNew(&new_FITScLcLCompression);
      instance.SetNewArray(&newArray_FITScLcLCompression);
      instance.SetDelete(&delete_FITScLcLCompression);
      instance.SetDeleteArray(&deleteArray_FITScLcLCompression);
      instance.SetDestructor(&destruct_FITScLcLCompression);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::FITS::Compression*)
   {
      return GenerateInitInstanceLocal((::FITS::Compression*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FITS::Compression*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FITScLcLCompression_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::FITS::Compression*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void izstream_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void izstream_Dictionary();
   static void *new_izstream(void *p = 0);
   static void *newArray_izstream(Long_t size, void *p);
   static void delete_izstream(void *p);
   static void deleteArray_izstream(void *p);
   static void destruct_izstream(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::izstream*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::izstream) == sizeof( ::ROOTShadow::Shadow::izstream));
      ::izstream *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::izstream),0);
      static ::ROOT::TGenericClassInfo 
         instance("izstream", "./mcore/izstream.h", 16,
                  typeid(::izstream), ::ROOT::DefineBehavior(ptr, ptr),
                  &izstream_ShowMembers, &izstream_Dictionary, isa_proxy, 4,
                  sizeof(::izstream) );
      instance.SetNew(&new_izstream);
      instance.SetNewArray(&newArray_izstream);
      instance.SetDelete(&delete_izstream);
      instance.SetDeleteArray(&deleteArray_izstream);
      instance.SetDestructor(&destruct_izstream);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::izstream*)
   {
      return GenerateInitInstanceLocal((::izstream*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::izstream*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void izstream_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::izstream*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void Checksum_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Checksum_Dictionary();
   static void *new_Checksum(void *p = 0);
   static void *newArray_Checksum(Long_t size, void *p);
   static void delete_Checksum(void *p);
   static void deleteArray_Checksum(void *p);
   static void destruct_Checksum(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Checksum*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Checksum) == sizeof( ::ROOTShadow::Shadow::Checksum));
      ::Checksum *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Checksum),0);
      static ::ROOT::TGenericClassInfo 
         instance("Checksum", "./mcore/checksum.h", 11,
                  typeid(::Checksum), ::ROOT::DefineBehavior(ptr, ptr),
                  &Checksum_ShowMembers, &Checksum_Dictionary, isa_proxy, 4,
                  sizeof(::Checksum) );
      instance.SetNew(&new_Checksum);
      instance.SetNewArray(&newArray_Checksum);
      instance.SetDelete(&delete_Checksum);
      instance.SetDeleteArray(&deleteArray_Checksum);
      instance.SetDestructor(&destruct_Checksum);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Checksum*)
   {
      return GenerateInitInstanceLocal((::Checksum*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Checksum*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Checksum_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Checksum*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void fits_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void fits_Dictionary();
   static void *new_fits(void *p = 0);
   static void *newArray_fits(Long_t size, void *p);
   static void delete_fits(void *p);
   static void deleteArray_fits(void *p);
   static void destruct_fits(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::fits*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::fits) == sizeof( ::ROOTShadow::Shadow::fits));
      ::fits *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::fits),0);
      static ::ROOT::TGenericClassInfo 
         instance("fits", "./mcore/fits.h", 55,
                  typeid(::fits), ::ROOT::DefineBehavior(ptr, ptr),
                  &fits_ShowMembers, &fits_Dictionary, isa_proxy, 4,
                  sizeof(::fits) );
      instance.SetNew(&new_fits);
      instance.SetNewArray(&newArray_fits);
      instance.SetDelete(&delete_fits);
      instance.SetDeleteArray(&deleteArray_fits);
      instance.SetDestructor(&destruct_fits);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::fits*)
   {
      return GenerateInitInstanceLocal((::fits*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::fits*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void fits_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::fits*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ofits_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ofits_Dictionary();
   static void *new_ofits(void *p = 0);
   static void *newArray_ofits(Long_t size, void *p);
   static void delete_ofits(void *p);
   static void deleteArray_ofits(void *p);
   static void destruct_ofits(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ofits*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ofits) == sizeof( ::ROOTShadow::Shadow::ofits));
      ::ofits *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ofits),0);
      static ::ROOT::TGenericClassInfo 
         instance("ofits", "./mcore/ofits.h", 30,
                  typeid(::ofits), ::ROOT::DefineBehavior(ptr, ptr),
                  &ofits_ShowMembers, &ofits_Dictionary, isa_proxy, 4,
                  sizeof(::ofits) );
      instance.SetNew(&new_ofits);
      instance.SetNewArray(&newArray_ofits);
      instance.SetDelete(&delete_ofits);
      instance.SetDeleteArray(&deleteArray_ofits);
      instance.SetDestructor(&destruct_ofits);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ofits*)
   {
      return GenerateInitInstanceLocal((::ofits*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ofits*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ofits_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ofits*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace Huffman {
   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void Huffman_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("Huffman", 0 /*version*/, "./mcore/huffman.h", 16,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &Huffman_Dictionary, 4);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void Huffman_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOTDict {
   void zofits_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void zofits_Dictionary();
   static void *new_zofits(void *p = 0);
   static void *newArray_zofits(Long_t size, void *p);
   static void delete_zofits(void *p);
   static void deleteArray_zofits(void *p);
   static void destruct_zofits(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::zofits*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::zofits) == sizeof( ::ROOTShadow::Shadow::zofits));
      ::zofits *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::zofits),0);
      static ::ROOT::TGenericClassInfo 
         instance("zofits", "./mcore/zofits.h", 29,
                  typeid(::zofits), ::ROOT::DefineBehavior(ptr, ptr),
                  &zofits_ShowMembers, &zofits_Dictionary, isa_proxy, 4,
                  sizeof(::zofits) );
      instance.SetNew(&new_zofits);
      instance.SetNewArray(&newArray_zofits);
      instance.SetDelete(&delete_zofits);
      instance.SetDeleteArray(&deleteArray_zofits);
      instance.SetDestructor(&destruct_zofits);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::zofits*)
   {
      return GenerateInitInstanceLocal((::zofits*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::zofits*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void zofits_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::zofits*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void DrsCalibrateTime_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DrsCalibrateTime_Dictionary();
   static void *new_DrsCalibrateTime(void *p = 0);
   static void *newArray_DrsCalibrateTime(Long_t size, void *p);
   static void delete_DrsCalibrateTime(void *p);
   static void deleteArray_DrsCalibrateTime(void *p);
   static void destruct_DrsCalibrateTime(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::DrsCalibrateTime*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::DrsCalibrateTime) == sizeof( ::ROOTShadow::Shadow::DrsCalibrateTime));
      ::DrsCalibrateTime *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DrsCalibrateTime),0);
      static ::ROOT::TGenericClassInfo 
         instance("DrsCalibrateTime", "./mcore/DrsCalib.h", 931,
                  typeid(::DrsCalibrateTime), ::ROOT::DefineBehavior(ptr, ptr),
                  &DrsCalibrateTime_ShowMembers, &DrsCalibrateTime_Dictionary, isa_proxy, 4,
                  sizeof(::DrsCalibrateTime) );
      instance.SetNew(&new_DrsCalibrateTime);
      instance.SetNewArray(&newArray_DrsCalibrateTime);
      instance.SetDelete(&delete_DrsCalibrateTime);
      instance.SetDeleteArray(&deleteArray_DrsCalibrateTime);
      instance.SetDestructor(&destruct_DrsCalibrateTime);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::DrsCalibrateTime*)
   {
      return GenerateInitInstanceLocal((::DrsCalibrateTime*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DrsCalibrateTime*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DrsCalibrateTime_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::DrsCalibrateTime*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void factofits_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void factofits_Dictionary();
   static void *new_factofits(void *p = 0);
   static void *newArray_factofits(Long_t size, void *p);
   static void delete_factofits(void *p);
   static void deleteArray_factofits(void *p);
   static void destruct_factofits(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::factofits*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::factofits) == sizeof( ::ROOTShadow::Shadow::factofits));
      ::factofits *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::factofits),0);
      static ::ROOT::TGenericClassInfo 
         instance("factofits", "./mcore/factofits.h", 17,
                  typeid(::factofits), ::ROOT::DefineBehavior(ptr, ptr),
                  &factofits_ShowMembers, &factofits_Dictionary, isa_proxy, 4,
                  sizeof(::factofits) );
      instance.SetNew(&new_factofits);
      instance.SetNewArray(&newArray_factofits);
      instance.SetDelete(&delete_factofits);
      instance.SetDeleteArray(&deleteArray_factofits);
      instance.SetDestructor(&destruct_factofits);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::factofits*)
   {
      return GenerateInitInstanceLocal((::factofits*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::factofits*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void factofits_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::factofits*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void zfits_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void zfits_Dictionary();
   static void delete_zfits(void *p);
   static void deleteArray_zfits(void *p);
   static void destruct_zfits(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::zfits*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::zfits) == sizeof( ::ROOTShadow::Shadow::zfits));
      ::zfits *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::zfits),0);
      static ::ROOT::TGenericClassInfo 
         instance("zfits", "./mcore/zfits.h", 17,
                  typeid(::zfits), ::ROOT::DefineBehavior(ptr, ptr),
                  &zfits_ShowMembers, &zfits_Dictionary, isa_proxy, 4,
                  sizeof(::zfits) );
      instance.SetDelete(&delete_zfits);
      instance.SetDeleteArray(&deleteArray_zfits);
      instance.SetDestructor(&destruct_zfits);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::zfits*)
   {
      return GenerateInitInstanceLocal((::zfits*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::zfits*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void zfits_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::zfits*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void factfits_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void factfits_Dictionary();
   static void delete_factfits(void *p);
   static void deleteArray_factfits(void *p);
   static void destruct_factfits(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::factfits*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::factfits) == sizeof( ::ROOTShadow::Shadow::factfits));
      ::factfits *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::factfits),0);
      static ::ROOT::TGenericClassInfo 
         instance("factfits", "./mcore/factfits.h", 14,
                  typeid(::factfits), ::ROOT::DefineBehavior(ptr, ptr),
                  &factfits_ShowMembers, &factfits_Dictionary, isa_proxy, 4,
                  sizeof(::factfits) );
      instance.SetDelete(&delete_factfits);
      instance.SetDeleteArray(&deleteArray_factfits);
      instance.SetDestructor(&destruct_factfits);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::factfits*)
   {
      return GenerateInitInstanceLocal((::factfits*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::factfits*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void factfits_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::factfits*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PixelMapEntry_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PixelMapEntry_Dictionary();
   static void *new_PixelMapEntry(void *p = 0);
   static void *newArray_PixelMapEntry(Long_t size, void *p);
   static void delete_PixelMapEntry(void *p);
   static void deleteArray_PixelMapEntry(void *p);
   static void destruct_PixelMapEntry(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PixelMapEntry*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::PixelMapEntry) == sizeof( ::ROOTShadow::Shadow::PixelMapEntry));
      ::PixelMapEntry *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PixelMapEntry),0);
      static ::ROOT::TGenericClassInfo 
         instance("PixelMapEntry", "./mcore/PixelMap.h", 25,
                  typeid(::PixelMapEntry), ::ROOT::DefineBehavior(ptr, ptr),
                  &PixelMapEntry_ShowMembers, &PixelMapEntry_Dictionary, isa_proxy, 4,
                  sizeof(::PixelMapEntry) );
      instance.SetNew(&new_PixelMapEntry);
      instance.SetNewArray(&newArray_PixelMapEntry);
      instance.SetDelete(&delete_PixelMapEntry);
      instance.SetDeleteArray(&deleteArray_PixelMapEntry);
      instance.SetDestructor(&destruct_PixelMapEntry);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PixelMapEntry*)
   {
      return GenerateInitInstanceLocal((::PixelMapEntry*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PixelMapEntry*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PixelMapEntry_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PixelMapEntry*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void PixelMap_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PixelMap_Dictionary();
   static void *new_PixelMap(void *p = 0);
   static void *newArray_PixelMap(Long_t size, void *p);
   static void delete_PixelMap(void *p);
   static void deleteArray_PixelMap(void *p);
   static void destruct_PixelMap(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::PixelMap*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::PixelMap) == sizeof( ::ROOTShadow::Shadow::PixelMap));
      ::PixelMap *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PixelMap),0);
      static ::ROOT::TGenericClassInfo 
         instance("PixelMap", "./mcore/PixelMap.h", 50,
                  typeid(::PixelMap), ::ROOT::DefineBehavior(ptr, ptr),
                  &PixelMap_ShowMembers, &PixelMap_Dictionary, isa_proxy, 4,
                  sizeof(::PixelMap) );
      instance.SetNew(&new_PixelMap);
      instance.SetNewArray(&newArray_PixelMap);
      instance.SetDelete(&delete_PixelMap);
      instance.SetDeleteArray(&deleteArray_PixelMap);
      instance.SetDestructor(&destruct_PixelMap);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::PixelMap*)
   {
      return GenerateInitInstanceLocal((::PixelMap*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PixelMap*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PixelMap_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::PixelMap*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void BiasMapEntry_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void BiasMapEntry_Dictionary();
   static void *new_BiasMapEntry(void *p = 0);
   static void *newArray_BiasMapEntry(Long_t size, void *p);
   static void delete_BiasMapEntry(void *p);
   static void deleteArray_BiasMapEntry(void *p);
   static void destruct_BiasMapEntry(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::BiasMapEntry*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::BiasMapEntry) == sizeof( ::ROOTShadow::Shadow::BiasMapEntry));
      ::BiasMapEntry *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BiasMapEntry),0);
      static ::ROOT::TGenericClassInfo 
         instance("BiasMapEntry", "./mcore/PixelMap.h", 200,
                  typeid(::BiasMapEntry), ::ROOT::DefineBehavior(ptr, ptr),
                  &BiasMapEntry_ShowMembers, &BiasMapEntry_Dictionary, isa_proxy, 4,
                  sizeof(::BiasMapEntry) );
      instance.SetNew(&new_BiasMapEntry);
      instance.SetNewArray(&newArray_BiasMapEntry);
      instance.SetDelete(&delete_BiasMapEntry);
      instance.SetDeleteArray(&deleteArray_BiasMapEntry);
      instance.SetDestructor(&destruct_BiasMapEntry);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::BiasMapEntry*)
   {
      return GenerateInitInstanceLocal((::BiasMapEntry*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BiasMapEntry*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void BiasMapEntry_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::BiasMapEntry*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void BiasMap_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void BiasMap_Dictionary();
   static void *new_BiasMap(void *p = 0);
   static void *newArray_BiasMap(Long_t size, void *p);
   static void delete_BiasMap(void *p);
   static void deleteArray_BiasMap(void *p);
   static void destruct_BiasMap(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::BiasMap*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::BiasMap) == sizeof( ::ROOTShadow::Shadow::BiasMap));
      ::BiasMap *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BiasMap),0);
      static ::ROOT::TGenericClassInfo 
         instance("BiasMap", "./mcore/PixelMap.h", 217,
                  typeid(::BiasMap), ::ROOT::DefineBehavior(ptr, ptr),
                  &BiasMap_ShowMembers, &BiasMap_Dictionary, isa_proxy, 4,
                  sizeof(::BiasMap) );
      instance.SetNew(&new_BiasMap);
      instance.SetNewArray(&newArray_BiasMap);
      instance.SetDelete(&delete_BiasMap);
      instance.SetDeleteArray(&deleteArray_BiasMap);
      instance.SetDestructor(&destruct_BiasMap);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::BiasMap*)
   {
      return GenerateInitInstanceLocal((::BiasMap*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BiasMap*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void BiasMap_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::BiasMap*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void Interpolator2D_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Interpolator2D_Dictionary();
   static void *new_Interpolator2D(void *p = 0);
   static void *newArray_Interpolator2D(Long_t size, void *p);
   static void delete_Interpolator2D(void *p);
   static void deleteArray_Interpolator2D(void *p);
   static void destruct_Interpolator2D(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Interpolator2D*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Interpolator2D) == sizeof( ::ROOTShadow::Shadow::Interpolator2D));
      ::Interpolator2D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Interpolator2D),0);
      static ::ROOT::TGenericClassInfo 
         instance("Interpolator2D", "./mcore/Interpolator2D.h", 25,
                  typeid(::Interpolator2D), ::ROOT::DefineBehavior(ptr, ptr),
                  &Interpolator2D_ShowMembers, &Interpolator2D_Dictionary, isa_proxy, 4,
                  sizeof(::Interpolator2D) );
      instance.SetNew(&new_Interpolator2D);
      instance.SetNewArray(&newArray_Interpolator2D);
      instance.SetDelete(&delete_Interpolator2D);
      instance.SetDeleteArray(&deleteArray_Interpolator2D);
      instance.SetDestructor(&destruct_Interpolator2D);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Interpolator2D*)
   {
      return GenerateInitInstanceLocal((::Interpolator2D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Interpolator2D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Interpolator2D_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Interpolator2D*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ln_equ_posn_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ln_equ_posn_Dictionary();
   static void *new_ln_equ_posn(void *p = 0);
   static void *newArray_ln_equ_posn(Long_t size, void *p);
   static void delete_ln_equ_posn(void *p);
   static void deleteArray_ln_equ_posn(void *p);
   static void destruct_ln_equ_posn(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ln_equ_posn*)
   {
      ::ln_equ_posn *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ln_equ_posn),0);
      static ::ROOT::TGenericClassInfo 
         instance("ln_equ_posn", "/usr/include/libnova/ln_types.h", 159,
                  typeid(::ln_equ_posn), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ln_equ_posn_Dictionary, isa_proxy, 0,
                  sizeof(::ln_equ_posn) );
      instance.SetNew(&new_ln_equ_posn);
      instance.SetNewArray(&newArray_ln_equ_posn);
      instance.SetDelete(&delete_ln_equ_posn);
      instance.SetDeleteArray(&deleteArray_ln_equ_posn);
      instance.SetDestructor(&destruct_ln_equ_posn);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ln_equ_posn*)
   {
      return GenerateInitInstanceLocal((::ln_equ_posn*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ln_equ_posn*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ln_equ_posn_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ln_equ_posn*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ln_hrz_posn_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ln_hrz_posn_Dictionary();
   static void *new_ln_hrz_posn(void *p = 0);
   static void *newArray_ln_hrz_posn(Long_t size, void *p);
   static void delete_ln_hrz_posn(void *p);
   static void deleteArray_ln_hrz_posn(void *p);
   static void destruct_ln_hrz_posn(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ln_hrz_posn*)
   {
      ::ln_hrz_posn *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ln_hrz_posn),0);
      static ::ROOT::TGenericClassInfo 
         instance("ln_hrz_posn", "/usr/include/libnova/ln_types.h", 173,
                  typeid(::ln_hrz_posn), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ln_hrz_posn_Dictionary, isa_proxy, 0,
                  sizeof(::ln_hrz_posn) );
      instance.SetNew(&new_ln_hrz_posn);
      instance.SetNewArray(&newArray_ln_hrz_posn);
      instance.SetDelete(&delete_ln_hrz_posn);
      instance.SetDeleteArray(&deleteArray_ln_hrz_posn);
      instance.SetDestructor(&destruct_ln_hrz_posn);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ln_hrz_posn*)
   {
      return GenerateInitInstanceLocal((::ln_hrz_posn*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ln_hrz_posn*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ln_hrz_posn_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ln_hrz_posn*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ln_lnlat_posn_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ln_lnlat_posn_Dictionary();
   static void *new_ln_lnlat_posn(void *p = 0);
   static void *newArray_ln_lnlat_posn(Long_t size, void *p);
   static void delete_ln_lnlat_posn(void *p);
   static void deleteArray_ln_lnlat_posn(void *p);
   static void destruct_ln_lnlat_posn(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ln_lnlat_posn*)
   {
      ::ln_lnlat_posn *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ln_lnlat_posn),0);
      static ::ROOT::TGenericClassInfo 
         instance("ln_lnlat_posn", "/usr/include/libnova/ln_types.h", 189,
                  typeid(::ln_lnlat_posn), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ln_lnlat_posn_Dictionary, isa_proxy, 0,
                  sizeof(::ln_lnlat_posn) );
      instance.SetNew(&new_ln_lnlat_posn);
      instance.SetNewArray(&newArray_ln_lnlat_posn);
      instance.SetDelete(&delete_ln_lnlat_posn);
      instance.SetDeleteArray(&deleteArray_ln_lnlat_posn);
      instance.SetDestructor(&destruct_ln_lnlat_posn);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ln_lnlat_posn*)
   {
      return GenerateInitInstanceLocal((::ln_lnlat_posn*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ln_lnlat_posn*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ln_lnlat_posn_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ln_lnlat_posn*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void ln_rst_time_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ln_rst_time_Dictionary();
   static void *new_ln_rst_time(void *p = 0);
   static void *newArray_ln_rst_time(Long_t size, void *p);
   static void delete_ln_rst_time(void *p);
   static void deleteArray_ln_rst_time(void *p);
   static void destruct_ln_rst_time(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::ln_rst_time*)
   {
      ::ln_rst_time *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ln_rst_time),0);
      static ::ROOT::TGenericClassInfo 
         instance("ln_rst_time", "/usr/include/libnova/ln_types.h", 306,
                  typeid(::ln_rst_time), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &ln_rst_time_Dictionary, isa_proxy, 0,
                  sizeof(::ln_rst_time) );
      instance.SetNew(&new_ln_rst_time);
      instance.SetNewArray(&newArray_ln_rst_time);
      instance.SetDelete(&delete_ln_rst_time);
      instance.SetDeleteArray(&deleteArray_ln_rst_time);
      instance.SetDestructor(&destruct_ln_rst_time);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::ln_rst_time*)
   {
      return GenerateInitInstanceLocal((::ln_rst_time*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ln_rst_time*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ln_rst_time_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::ln_rst_time*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace Nova {
   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void Nova_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("Nova", 0 /*version*/, "./mcore/nova.h", 11,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &Nova_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void Nova_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOTDict {
   void NovacLcLZdAzPosn_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void NovacLcLZdAzPosn_Dictionary();
   static void *new_NovacLcLZdAzPosn(void *p = 0);
   static void *newArray_NovacLcLZdAzPosn(Long_t size, void *p);
   static void delete_NovacLcLZdAzPosn(void *p);
   static void deleteArray_NovacLcLZdAzPosn(void *p);
   static void destruct_NovacLcLZdAzPosn(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Nova::ZdAzPosn*)
   {
      ::Nova::ZdAzPosn *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Nova::ZdAzPosn),0);
      static ::ROOT::TGenericClassInfo 
         instance("Nova::ZdAzPosn", "./mcore/nova.h", 29,
                  typeid(::Nova::ZdAzPosn), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &NovacLcLZdAzPosn_Dictionary, isa_proxy, 0,
                  sizeof(::Nova::ZdAzPosn) );
      instance.SetNew(&new_NovacLcLZdAzPosn);
      instance.SetNewArray(&newArray_NovacLcLZdAzPosn);
      instance.SetDelete(&delete_NovacLcLZdAzPosn);
      instance.SetDeleteArray(&deleteArray_NovacLcLZdAzPosn);
      instance.SetDestructor(&destruct_NovacLcLZdAzPosn);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Nova::ZdAzPosn*)
   {
      return GenerateInitInstanceLocal((::Nova::ZdAzPosn*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Nova::ZdAzPosn*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void NovacLcLZdAzPosn_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Nova::ZdAzPosn*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void NovacLcLRaDecPosn_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void NovacLcLRaDecPosn_Dictionary();
   static void *new_NovacLcLRaDecPosn(void *p = 0);
   static void *newArray_NovacLcLRaDecPosn(Long_t size, void *p);
   static void delete_NovacLcLRaDecPosn(void *p);
   static void deleteArray_NovacLcLRaDecPosn(void *p);
   static void destruct_NovacLcLRaDecPosn(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Nova::RaDecPosn*)
   {
      ::Nova::RaDecPosn *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Nova::RaDecPosn),0);
      static ::ROOT::TGenericClassInfo 
         instance("Nova::RaDecPosn", "./mcore/nova.h", 51,
                  typeid(::Nova::RaDecPosn), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &NovacLcLRaDecPosn_Dictionary, isa_proxy, 0,
                  sizeof(::Nova::RaDecPosn) );
      instance.SetNew(&new_NovacLcLRaDecPosn);
      instance.SetNewArray(&newArray_NovacLcLRaDecPosn);
      instance.SetDelete(&delete_NovacLcLRaDecPosn);
      instance.SetDeleteArray(&deleteArray_NovacLcLRaDecPosn);
      instance.SetDestructor(&destruct_NovacLcLRaDecPosn);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Nova::RaDecPosn*)
   {
      return GenerateInitInstanceLocal((::Nova::RaDecPosn*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Nova::RaDecPosn*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void NovacLcLRaDecPosn_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Nova::RaDecPosn*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void NovacLcLHrzPosn_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void NovacLcLHrzPosn_Dictionary();
   static void *new_NovacLcLHrzPosn(void *p = 0);
   static void *newArray_NovacLcLHrzPosn(Long_t size, void *p);
   static void delete_NovacLcLHrzPosn(void *p);
   static void deleteArray_NovacLcLHrzPosn(void *p);
   static void destruct_NovacLcLHrzPosn(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Nova::HrzPosn*)
   {
      ::Nova::HrzPosn *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Nova::HrzPosn),0);
      static ::ROOT::TGenericClassInfo 
         instance("Nova::HrzPosn", "./mcore/nova.h", 23,
                  typeid(::Nova::HrzPosn), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &NovacLcLHrzPosn_Dictionary, isa_proxy, 0,
                  sizeof(::Nova::HrzPosn) );
      instance.SetNew(&new_NovacLcLHrzPosn);
      instance.SetNewArray(&newArray_NovacLcLHrzPosn);
      instance.SetDelete(&delete_NovacLcLHrzPosn);
      instance.SetDeleteArray(&deleteArray_NovacLcLHrzPosn);
      instance.SetDestructor(&destruct_NovacLcLHrzPosn);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Nova::HrzPosn*)
   {
      return GenerateInitInstanceLocal((::Nova::HrzPosn*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Nova::HrzPosn*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void NovacLcLHrzPosn_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Nova::HrzPosn*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void NovacLcLEquPosn_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void NovacLcLEquPosn_Dictionary();
   static void *new_NovacLcLEquPosn(void *p = 0);
   static void *newArray_NovacLcLEquPosn(Long_t size, void *p);
   static void delete_NovacLcLEquPosn(void *p);
   static void deleteArray_NovacLcLEquPosn(void *p);
   static void destruct_NovacLcLEquPosn(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::Nova::EquPosn*)
   {
      ::Nova::EquPosn *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Nova::EquPosn),0);
      static ::ROOT::TGenericClassInfo 
         instance("Nova::EquPosn", "./mcore/nova.h", 45,
                  typeid(::Nova::EquPosn), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &NovacLcLEquPosn_Dictionary, isa_proxy, 0,
                  sizeof(::Nova::EquPosn) );
      instance.SetNew(&new_NovacLcLEquPosn);
      instance.SetNewArray(&newArray_NovacLcLEquPosn);
      instance.SetDelete(&delete_NovacLcLEquPosn);
      instance.SetDeleteArray(&deleteArray_NovacLcLEquPosn);
      instance.SetDestructor(&destruct_NovacLcLEquPosn);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::Nova::EquPosn*)
   {
      return GenerateInitInstanceLocal((::Nova::EquPosn*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Nova::EquPosn*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void NovacLcLEquPosn_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::Nova::EquPosn*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace FACT {
   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void FACT_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("FACT", 0 /*version*/, "./mcore/Prediction.h", 9,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &FACT_Dictionary, 4);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void FACT_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}

//______________________________________________________________________________
namespace ROOTDict {
   void Checksum_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Checksum.
      typedef ::ROOTShadow::Shadow::Checksum ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::Checksum*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "buffer", &sobj->buffer);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_Checksum(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Checksum : new ::Checksum;
   }
   static void *newArray_Checksum(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Checksum[nElements] : new ::Checksum[nElements];
   }
   // Wrapper around operator delete
   static void delete_Checksum(void *p) {
      delete ((::Checksum*)p);
   }
   static void deleteArray_Checksum(void *p) {
      delete [] ((::Checksum*)p);
   }
   static void destruct_Checksum(void *p) {
      typedef ::Checksum current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Checksum

//______________________________________________________________________________
namespace ROOTDict {
   void izstream_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class izstream.
      typedef ::ROOTShadow::Shadow::izstream ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::izstream*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFile", &sobj->fFile);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fBuffer", &sobj->fBuffer);
      R__insp.GenericShowMembers("basic_streambuf<char,char_traits<char> >", ( ::basic_streambuf<char,char_traits<char> > * )( (::izstream*) obj ), false);
      R__insp.GenericShowMembers("basic_istream<char,char_traits<char> >", ( ::basic_istream<char,char_traits<char> > * )( (::izstream*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_izstream(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::izstream : new ::izstream;
   }
   static void *newArray_izstream(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::izstream[nElements] : new ::izstream[nElements];
   }
   // Wrapper around operator delete
   static void delete_izstream(void *p) {
      delete ((::izstream*)p);
   }
   static void deleteArray_izstream(void *p) {
      delete [] ((::izstream*)p);
   }
   static void destruct_izstream(void *p) {
      typedef ::izstream current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::izstream

//______________________________________________________________________________
namespace ROOTDict {
   void fits_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class fits.
      typedef ::ROOTShadow::Shadow::fits ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::fits*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCopy", (void*)&sobj->fCopy);
      R__insp.InspectMember("ofstream", (void*)&sobj->fCopy, "fCopy.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fListOfTables", (void*)&sobj->fListOfTables);
      R__insp.InspectMember("vector<std::string>", (void*)&sobj->fListOfTables, "fListOfTables.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTable", (void*)&sobj->fTable);
      R__insp.InspectMember("fits::Table", (void*)&sobj->fTable, "fTable.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fAddresses", (void*)&sobj->fAddresses);
      R__insp.InspectMember("fits::Addresses", (void*)&sobj->fAddresses, "fAddresses.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fPointers", (void*)&sobj->fPointers);
      R__insp.InspectMember("fits::Pointers", (void*)&sobj->fPointers, "fPointers.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fGarbage", (void*)&sobj->fGarbage);
      R__insp.InspectMember("vector<std::vector<char> >", (void*)&sobj->fGarbage, "fGarbage.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBufferRow", (void*)&sobj->fBufferRow);
      R__insp.InspectMember("vector<char>", (void*)&sobj->fBufferRow, "fBufferRow.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBufferDat", (void*)&sobj->fBufferDat);
      R__insp.InspectMember("vector<char>", (void*)&sobj->fBufferDat, "fBufferDat.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRow", &sobj->fRow);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fChkHeader", (void*)&sobj->fChkHeader);
      R__insp.InspectMember("Checksum", (void*)&sobj->fChkHeader, "fChkHeader.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fChkData", (void*)&sobj->fChkData);
      R__insp.InspectMember("Checksum", (void*)&sobj->fChkData, "fChkData.", false);
      R__insp.GenericShowMembers("izstream", ( ::izstream * )( (::fits*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_fits(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::fits : new ::fits;
   }
   static void *newArray_fits(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::fits[nElements] : new ::fits[nElements];
   }
   // Wrapper around operator delete
   static void delete_fits(void *p) {
      delete ((::fits*)p);
   }
   static void deleteArray_fits(void *p) {
      delete [] ((::fits*)p);
   }
   static void destruct_fits(void *p) {
      typedef ::fits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::fits

//______________________________________________________________________________
namespace ROOTDict {
   void ofits_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ofits.
      typedef ::ROOTShadow::Shadow::ofits ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::ofits*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fFilebuf", (void*)&sobj->fFilebuf);
      R__insp.InspectMember("filebuf", (void*)&sobj->fFilebuf, "fFilebuf.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fKeys", (void*)&sobj->fKeys);
      R__insp.InspectMember("vector<Key>", (void*)&sobj->fKeys, "fKeys.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTable", (void*)&sobj->fTable);
      R__insp.InspectMember("ofits::Table", (void*)&sobj->fTable, "fTable.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOutputBuffer", (void*)&sobj->fOutputBuffer);
      R__insp.InspectMember("vector<char>", (void*)&sobj->fOutputBuffer, "fOutputBuffer.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDataSum", (void*)&sobj->fDataSum);
      R__insp.InspectMember("Checksum", (void*)&sobj->fDataSum, "fDataSum.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fHeaderSum", (void*)&sobj->fHeaderSum);
      R__insp.InspectMember("Checksum", (void*)&sobj->fHeaderSum, "fHeaderSum.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCommentTrimming", &sobj->fCommentTrimming);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fManualExtName", &sobj->fManualExtName);
      R__insp.GenericShowMembers("basic_ostream<char,char_traits<char> >", ( ::basic_ostream<char,char_traits<char> > * )( (::ofits*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ofits(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ofits : new ::ofits;
   }
   static void *newArray_ofits(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ofits[nElements] : new ::ofits[nElements];
   }
   // Wrapper around operator delete
   static void delete_ofits(void *p) {
      delete ((::ofits*)p);
   }
   static void deleteArray_ofits(void *p) {
      delete [] ((::ofits*)p);
   }
   static void destruct_ofits(void *p) {
      typedef ::ofits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ofits

//______________________________________________________________________________
namespace ROOTDict {
   void zfits_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class zfits.
      typedef ::ROOTShadow::Shadow::zfits ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::zfits*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCatalogInitialized", &sobj->fCatalogInitialized);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBuffer", (void*)&sobj->fBuffer);
      R__insp.InspectMember("vector<char>", (void*)&sobj->fBuffer, "fBuffer.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTransposedBuffer", (void*)&sobj->fTransposedBuffer);
      R__insp.InspectMember("vector<char>", (void*)&sobj->fTransposedBuffer, "fTransposedBuffer.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCompressedBuffer", (void*)&sobj->fCompressedBuffer);
      R__insp.InspectMember("vector<char>", (void*)&sobj->fCompressedBuffer, "fCompressedBuffer.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fColumnOrdering", (void*)&sobj->fColumnOrdering);
      R__insp.InspectMember("vector<char>", (void*)&sobj->fColumnOrdering, "fColumnOrdering.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumTiles", &sobj->fNumTiles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumRowsPerTile", &sobj->fNumRowsPerTile);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCurrentRow", &sobj->fCurrentRow);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fShrinkFactor", &sobj->fShrinkFactor);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fHeapOff", &sobj->fHeapOff);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fHeapFromDataStart", &sobj->fHeapFromDataStart);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCatalog", (void*)&sobj->fCatalog);
      R__insp.InspectMember("vector<std::vector<std::pair<int64_t,int64_t> > >", (void*)&sobj->fCatalog, "fCatalog.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTileSize", (void*)&sobj->fTileSize);
      R__insp.InspectMember("vector<size_t>", (void*)&sobj->fTileSize, "fTileSize.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fTileOffsets", (void*)&sobj->fTileOffsets);
      R__insp.InspectMember("vector<std::vector<size_t> >", (void*)&sobj->fTileOffsets, "fTileOffsets.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRawsum", (void*)&sobj->fRawsum);
      R__insp.InspectMember("Checksum", (void*)&sobj->fRawsum, "fRawsum.", false);
      R__insp.GenericShowMembers("fits", ( ::fits * )( (::zfits*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrapper around operator delete
   static void delete_zfits(void *p) {
      delete ((::zfits*)p);
   }
   static void deleteArray_zfits(void *p) {
      delete [] ((::zfits*)p);
   }
   static void destruct_zfits(void *p) {
      typedef ::zfits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::zfits

//______________________________________________________________________________
namespace ROOTDict {
   void zofits_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class zofits.
      typedef ::ROOTShadow::Shadow::zofits ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::zofits*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMemPool", (void*)&sobj->fMemPool);
      R__insp.InspectMember("MemoryManager", (void*)&sobj->fMemPool, "fMemPool.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumQueues", &sobj->fNumQueues);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMaxUsableMem", &sobj->fMaxUsableMem);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLatestWrittenTile", &sobj->fLatestWrittenTile);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCompressionQueues", (void*)&sobj->fCompressionQueues);
      R__insp.InspectMember("vector<Queue<CompressionTarget> >", (void*)&sobj->fCompressionQueues, "fCompressionQueues.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fWriteToDiskQueue", (void*)&sobj->fWriteToDiskQueue);
      R__insp.InspectMember("zofits::Queue<WriteTarget,QueueMin<WriteTarget> >", (void*)&sobj->fWriteToDiskQueue, "fWriteToDiskQueue.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCatalog", (void*)&sobj->fCatalog);
      R__insp.InspectMember("zofits::CatalogType", (void*)&sobj->fCatalog, "fCatalog.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCatalogSize", &sobj->fCatalogSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumTiles", &sobj->fNumTiles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumRowsPerTile", &sobj->fNumRowsPerTile);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCatalogOffset", &sobj->fCatalogOffset);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCatalogSum", (void*)&sobj->fCatalogSum);
      R__insp.InspectMember("Checksum", (void*)&sobj->fCatalogSum, "fCatalogSum.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRawSum", (void*)&sobj->fRawSum);
      R__insp.InspectMember("Checksum", (void*)&sobj->fRawSum, "fRawSum.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCheckOffset", &sobj->fCheckOffset);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRealColumns", (void*)&sobj->fRealColumns);
      R__insp.InspectMember("vector<CompressedColumn>", (void*)&sobj->fRealColumns, "fRealColumns.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRealRowWidth", &sobj->fRealRowWidth);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSmartBuffer", (void*)&sobj->fSmartBuffer);
      R__insp.InspectMember("shared_ptr<char>", (void*)&sobj->fSmartBuffer, "fSmartBuffer.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRawSumBuffer", (void*)&sobj->fRawSumBuffer);
      R__insp.InspectMember("vector<char>", (void*)&sobj->fRawSumBuffer, "fRawSumBuffer.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fThreadsException", &sobj->fThreadsException);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fErrno", &sobj->fErrno);
      R__insp.GenericShowMembers("ofits", ( ::ofits * )( (::zofits*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_zofits(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::zofits : new ::zofits;
   }
   static void *newArray_zofits(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::zofits[nElements] : new ::zofits[nElements];
   }
   // Wrapper around operator delete
   static void delete_zofits(void *p) {
      delete ((::zofits*)p);
   }
   static void deleteArray_zofits(void *p) {
      delete [] ((::zofits*)p);
   }
   static void destruct_zofits(void *p) {
      typedef ::zofits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::zofits

//______________________________________________________________________________
namespace ROOTDict {
   void factfits_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class factfits.
      typedef ::ROOTShadow::Shadow::factfits ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::factfits*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOffsetCalibration", (void*)&sobj->fOffsetCalibration);
      R__insp.InspectMember("vector<int16_t>", (void*)&sobj->fOffsetCalibration, "fOffsetCalibration.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOffsetStartCellData", &sobj->fOffsetStartCellData);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOffsetData", &sobj->fOffsetData);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumRoi", &sobj->fNumRoi);
      R__insp.GenericShowMembers("zfits", ( ::zfits * )( (::factfits*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrapper around operator delete
   static void delete_factfits(void *p) {
      delete ((::factfits*)p);
   }
   static void deleteArray_factfits(void *p) {
      delete [] ((::factfits*)p);
   }
   static void destruct_factfits(void *p) {
      typedef ::factfits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::factfits

//______________________________________________________________________________
namespace ROOTDict {
   void factofits_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class factofits.
      typedef ::ROOTShadow::Shadow::factofits ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::factofits*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOffsetCalibration", (void*)&sobj->fOffsetCalibration);
      R__insp.InspectMember("vector<int16_t>", (void*)&sobj->fOffsetCalibration, "fOffsetCalibration.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStartCellsOffset", &sobj->fStartCellsOffset);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDataOffset", &sobj->fDataOffset);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumSlices", &sobj->fNumSlices);
      R__insp.GenericShowMembers("zofits", ( ::zofits * )( (::factofits*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_factofits(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::factofits : new ::factofits;
   }
   static void *newArray_factofits(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::factofits[nElements] : new ::factofits[nElements];
   }
   // Wrapper around operator delete
   static void delete_factofits(void *p) {
      delete ((::factofits*)p);
   }
   static void deleteArray_factofits(void *p) {
      delete [] ((::factofits*)p);
   }
   static void destruct_factofits(void *p) {
      typedef ::factofits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::factofits

//______________________________________________________________________________
namespace ROOTDict {
   void DrsCalibrateTime_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class DrsCalibrateTime.
      typedef ::ROOTShadow::Shadow::DrsCalibrateTime ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::DrsCalibrateTime*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumEntries", &sobj->fNumEntries);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumSamples", &sobj->fNumSamples);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNumChannels", &sobj->fNumChannels);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStat", (void*)&sobj->fStat);
      R__insp.InspectMember("vector<std::pair<double,double> >", (void*)&sobj->fStat, "fStat.", false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_DrsCalibrateTime(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DrsCalibrateTime : new ::DrsCalibrateTime;
   }
   static void *newArray_DrsCalibrateTime(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DrsCalibrateTime[nElements] : new ::DrsCalibrateTime[nElements];
   }
   // Wrapper around operator delete
   static void delete_DrsCalibrateTime(void *p) {
      delete ((::DrsCalibrateTime*)p);
   }
   static void deleteArray_DrsCalibrateTime(void *p) {
      delete [] ((::DrsCalibrateTime*)p);
   }
   static void destruct_DrsCalibrateTime(void *p) {
      typedef ::DrsCalibrateTime current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::DrsCalibrateTime

//______________________________________________________________________________
namespace ROOTDict {
   void PixelMap_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class PixelMap.
      typedef ::ROOTShadow::Shadow::PixelMap ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::PixelMap*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("vector<PixelMapEntry,allocator<PixelMapEntry> >", ( ::vector<PixelMapEntry,allocator<PixelMapEntry> > * )( (::PixelMap*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PixelMap(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PixelMap : new ::PixelMap;
   }
   static void *newArray_PixelMap(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PixelMap[nElements] : new ::PixelMap[nElements];
   }
   // Wrapper around operator delete
   static void delete_PixelMap(void *p) {
      delete ((::PixelMap*)p);
   }
   static void deleteArray_PixelMap(void *p) {
      delete [] ((::PixelMap*)p);
   }
   static void destruct_PixelMap(void *p) {
      typedef ::PixelMap current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PixelMap

//______________________________________________________________________________
namespace ROOTDict {
   void PixelMapEntry_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class PixelMapEntry.
      typedef ::ROOTShadow::Shadow::PixelMapEntry ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::PixelMapEntry*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "index", &sobj->index);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "cbpx", &sobj->cbpx);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "gapd", &sobj->gapd);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hv_board", &sobj->hv_board);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hv_channel", &sobj->hv_channel);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_PixelMapEntry(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PixelMapEntry : new ::PixelMapEntry;
   }
   static void *newArray_PixelMapEntry(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PixelMapEntry[nElements] : new ::PixelMapEntry[nElements];
   }
   // Wrapper around operator delete
   static void delete_PixelMapEntry(void *p) {
      delete ((::PixelMapEntry*)p);
   }
   static void deleteArray_PixelMapEntry(void *p) {
      delete [] ((::PixelMapEntry*)p);
   }
   static void destruct_PixelMapEntry(void *p) {
      typedef ::PixelMapEntry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::PixelMapEntry

//______________________________________________________________________________
namespace ROOTDict {
   void BiasMap_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class BiasMap.
      typedef ::ROOTShadow::Shadow::BiasMap ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::BiasMap*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("vector<BiasMapEntry,allocator<BiasMapEntry> >", ( ::vector<BiasMapEntry,allocator<BiasMapEntry> > * )( (::BiasMap*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_BiasMap(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BiasMap : new ::BiasMap;
   }
   static void *newArray_BiasMap(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BiasMap[nElements] : new ::BiasMap[nElements];
   }
   // Wrapper around operator delete
   static void delete_BiasMap(void *p) {
      delete ((::BiasMap*)p);
   }
   static void deleteArray_BiasMap(void *p) {
      delete [] ((::BiasMap*)p);
   }
   static void destruct_BiasMap(void *p) {
      typedef ::BiasMap current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::BiasMap

//______________________________________________________________________________
namespace ROOTDict {
   void BiasMapEntry_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class BiasMapEntry.
      typedef ::ROOTShadow::Shadow::BiasMapEntry ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::BiasMapEntry*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hv_board", &sobj->hv_board);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hv_channel", &sobj->hv_channel);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Vnom", &sobj->Vnom);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Voff", &sobj->Voff);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Vslope", &sobj->Vslope);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_BiasMapEntry(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BiasMapEntry : new ::BiasMapEntry;
   }
   static void *newArray_BiasMapEntry(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::BiasMapEntry[nElements] : new ::BiasMapEntry[nElements];
   }
   // Wrapper around operator delete
   static void delete_BiasMapEntry(void *p) {
      delete ((::BiasMapEntry*)p);
   }
   static void deleteArray_BiasMapEntry(void *p) {
      delete [] ((::BiasMapEntry*)p);
   }
   static void destruct_BiasMapEntry(void *p) {
      typedef ::BiasMapEntry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::BiasMapEntry

//______________________________________________________________________________
namespace ROOTDict {
   void Interpolator2D_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Interpolator2D.
      typedef ::ROOTShadow::Shadow::Interpolator2D ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::Interpolator2D*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "inputGrid", (void*)&sobj->inputGrid);
      R__insp.InspectMember("vector<point>", (void*)&sobj->inputGrid, "inputGrid.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "outputGrid", (void*)&sobj->outputGrid);
      R__insp.InspectMember("vector<point>", (void*)&sobj->outputGrid, "outputGrid.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "circles", (void*)&sobj->circles);
      R__insp.InspectMember("vector<circle>", (void*)&sobj->circles, "circles.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "weights", (void*)&sobj->weights);
      R__insp.InspectMember("vector<weight>", (void*)&sobj->weights, "weights.", false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_Interpolator2D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Interpolator2D : new ::Interpolator2D;
   }
   static void *newArray_Interpolator2D(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Interpolator2D[nElements] : new ::Interpolator2D[nElements];
   }
   // Wrapper around operator delete
   static void delete_Interpolator2D(void *p) {
      delete ((::Interpolator2D*)p);
   }
   static void deleteArray_Interpolator2D(void *p) {
      delete [] ((::Interpolator2D*)p);
   }
   static void destruct_Interpolator2D(void *p) {
      typedef ::Interpolator2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Interpolator2D

//______________________________________________________________________________
namespace ROOTDict {
   void FITScLcLCompression_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class FITS::Compression.
      typedef ::ROOTShadow::Shadow::FITS::Compression ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::FITS::Compression*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "sequence", (void*)&sobj->sequence);
      R__insp.InspectMember("vector<uint16_t>", (void*)&sobj->sequence, "sequence.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "header", (void*)&sobj->header);
      R__insp.InspectMember("FITS::BlockHeader", (void*)&sobj->header, "header.", false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_FITScLcLCompression(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FITS::Compression : new ::FITS::Compression;
   }
   static void *newArray_FITScLcLCompression(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FITS::Compression[nElements] : new ::FITS::Compression[nElements];
   }
   // Wrapper around operator delete
   static void delete_FITScLcLCompression(void *p) {
      delete ((::FITS::Compression*)p);
   }
   static void deleteArray_FITScLcLCompression(void *p) {
      delete [] ((::FITS::Compression*)p);
   }
   static void destruct_FITScLcLCompression(void *p) {
      typedef ::FITS::Compression current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::FITS::Compression

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ln_equ_posn(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ln_equ_posn : new ::ln_equ_posn;
   }
   static void *newArray_ln_equ_posn(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ln_equ_posn[nElements] : new ::ln_equ_posn[nElements];
   }
   // Wrapper around operator delete
   static void delete_ln_equ_posn(void *p) {
      delete ((::ln_equ_posn*)p);
   }
   static void deleteArray_ln_equ_posn(void *p) {
      delete [] ((::ln_equ_posn*)p);
   }
   static void destruct_ln_equ_posn(void *p) {
      typedef ::ln_equ_posn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ln_equ_posn

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ln_hrz_posn(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ln_hrz_posn : new ::ln_hrz_posn;
   }
   static void *newArray_ln_hrz_posn(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ln_hrz_posn[nElements] : new ::ln_hrz_posn[nElements];
   }
   // Wrapper around operator delete
   static void delete_ln_hrz_posn(void *p) {
      delete ((::ln_hrz_posn*)p);
   }
   static void deleteArray_ln_hrz_posn(void *p) {
      delete [] ((::ln_hrz_posn*)p);
   }
   static void destruct_ln_hrz_posn(void *p) {
      typedef ::ln_hrz_posn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ln_hrz_posn

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ln_lnlat_posn(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ln_lnlat_posn : new ::ln_lnlat_posn;
   }
   static void *newArray_ln_lnlat_posn(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ln_lnlat_posn[nElements] : new ::ln_lnlat_posn[nElements];
   }
   // Wrapper around operator delete
   static void delete_ln_lnlat_posn(void *p) {
      delete ((::ln_lnlat_posn*)p);
   }
   static void deleteArray_ln_lnlat_posn(void *p) {
      delete [] ((::ln_lnlat_posn*)p);
   }
   static void destruct_ln_lnlat_posn(void *p) {
      typedef ::ln_lnlat_posn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ln_lnlat_posn

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_ln_rst_time(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ln_rst_time : new ::ln_rst_time;
   }
   static void *newArray_ln_rst_time(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ln_rst_time[nElements] : new ::ln_rst_time[nElements];
   }
   // Wrapper around operator delete
   static void delete_ln_rst_time(void *p) {
      delete ((::ln_rst_time*)p);
   }
   static void deleteArray_ln_rst_time(void *p) {
      delete [] ((::ln_rst_time*)p);
   }
   static void destruct_ln_rst_time(void *p) {
      typedef ::ln_rst_time current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::ln_rst_time

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_NovacLcLZdAzPosn(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Nova::ZdAzPosn : new ::Nova::ZdAzPosn;
   }
   static void *newArray_NovacLcLZdAzPosn(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Nova::ZdAzPosn[nElements] : new ::Nova::ZdAzPosn[nElements];
   }
   // Wrapper around operator delete
   static void delete_NovacLcLZdAzPosn(void *p) {
      delete ((::Nova::ZdAzPosn*)p);
   }
   static void deleteArray_NovacLcLZdAzPosn(void *p) {
      delete [] ((::Nova::ZdAzPosn*)p);
   }
   static void destruct_NovacLcLZdAzPosn(void *p) {
      typedef ::Nova::ZdAzPosn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Nova::ZdAzPosn

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_NovacLcLRaDecPosn(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Nova::RaDecPosn : new ::Nova::RaDecPosn;
   }
   static void *newArray_NovacLcLRaDecPosn(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Nova::RaDecPosn[nElements] : new ::Nova::RaDecPosn[nElements];
   }
   // Wrapper around operator delete
   static void delete_NovacLcLRaDecPosn(void *p) {
      delete ((::Nova::RaDecPosn*)p);
   }
   static void deleteArray_NovacLcLRaDecPosn(void *p) {
      delete [] ((::Nova::RaDecPosn*)p);
   }
   static void destruct_NovacLcLRaDecPosn(void *p) {
      typedef ::Nova::RaDecPosn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Nova::RaDecPosn

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_NovacLcLHrzPosn(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Nova::HrzPosn : new ::Nova::HrzPosn;
   }
   static void *newArray_NovacLcLHrzPosn(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Nova::HrzPosn[nElements] : new ::Nova::HrzPosn[nElements];
   }
   // Wrapper around operator delete
   static void delete_NovacLcLHrzPosn(void *p) {
      delete ((::Nova::HrzPosn*)p);
   }
   static void deleteArray_NovacLcLHrzPosn(void *p) {
      delete [] ((::Nova::HrzPosn*)p);
   }
   static void destruct_NovacLcLHrzPosn(void *p) {
      typedef ::Nova::HrzPosn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Nova::HrzPosn

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_NovacLcLEquPosn(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Nova::EquPosn : new ::Nova::EquPosn;
   }
   static void *newArray_NovacLcLEquPosn(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Nova::EquPosn[nElements] : new ::Nova::EquPosn[nElements];
   }
   // Wrapper around operator delete
   static void delete_NovacLcLEquPosn(void *p) {
      delete ((::Nova::EquPosn*)p);
   }
   static void deleteArray_NovacLcLEquPosn(void *p) {
      delete [] ((::Nova::EquPosn*)p);
   }
   static void destruct_NovacLcLEquPosn(void *p) {
      typedef ::Nova::EquPosn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::Nova::EquPosn

namespace ROOTDict {
   void listlEvectorlEzofitscLcLCatalogEntrygRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void listlEvectorlEzofitscLcLCatalogEntrygRsPgR_Dictionary();
   static void *new_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(void *p = 0);
   static void *newArray_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(Long_t size, void *p);
   static void delete_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(void *p);
   static void deleteArray_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(void *p);
   static void destruct_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const list<vector<zofits::CatalogEntry> >*)
   {
      list<vector<zofits::CatalogEntry> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<vector<zofits::CatalogEntry> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("list<vector<zofits::CatalogEntry> >", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/list", 44,
                  typeid(list<vector<zofits::CatalogEntry> >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &listlEvectorlEzofitscLcLCatalogEntrygRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(list<vector<zofits::CatalogEntry> >) );
      instance.SetNew(&new_listlEvectorlEzofitscLcLCatalogEntrygRsPgR);
      instance.SetNewArray(&newArray_listlEvectorlEzofitscLcLCatalogEntrygRsPgR);
      instance.SetDelete(&delete_listlEvectorlEzofitscLcLCatalogEntrygRsPgR);
      instance.SetDeleteArray(&deleteArray_listlEvectorlEzofitscLcLCatalogEntrygRsPgR);
      instance.SetDestructor(&destruct_listlEvectorlEzofitscLcLCatalogEntrygRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< list<vector<zofits::CatalogEntry> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const list<vector<zofits::CatalogEntry> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void listlEvectorlEzofitscLcLCatalogEntrygRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const list<vector<zofits::CatalogEntry> >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) list<vector<zofits::CatalogEntry> > : new list<vector<zofits::CatalogEntry> >;
   }
   static void *newArray_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) list<vector<zofits::CatalogEntry> >[nElements] : new list<vector<zofits::CatalogEntry> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(void *p) {
      delete ((list<vector<zofits::CatalogEntry> >*)p);
   }
   static void deleteArray_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(void *p) {
      delete [] ((list<vector<zofits::CatalogEntry> >*)p);
   }
   static void destruct_listlEvectorlEzofitscLcLCatalogEntrygRsPgR(void *p) {
      typedef list<vector<zofits::CatalogEntry> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class list<vector<zofits::CatalogEntry> >

namespace ROOTDict {
   void vectorlEBiasMapEntrygR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEBiasMapEntrygR_Dictionary();
   static void *new_vectorlEBiasMapEntrygR(void *p = 0);
   static void *newArray_vectorlEBiasMapEntrygR(Long_t size, void *p);
   static void delete_vectorlEBiasMapEntrygR(void *p);
   static void deleteArray_vectorlEBiasMapEntrygR(void *p);
   static void destruct_vectorlEBiasMapEntrygR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<BiasMapEntry>*)
   {
      vector<BiasMapEntry> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<BiasMapEntry>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<BiasMapEntry>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<BiasMapEntry>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEBiasMapEntrygR_Dictionary, isa_proxy, 0,
                  sizeof(vector<BiasMapEntry>) );
      instance.SetNew(&new_vectorlEBiasMapEntrygR);
      instance.SetNewArray(&newArray_vectorlEBiasMapEntrygR);
      instance.SetDelete(&delete_vectorlEBiasMapEntrygR);
      instance.SetDeleteArray(&deleteArray_vectorlEBiasMapEntrygR);
      instance.SetDestructor(&destruct_vectorlEBiasMapEntrygR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<BiasMapEntry> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<BiasMapEntry>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEBiasMapEntrygR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<BiasMapEntry>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEBiasMapEntrygR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<BiasMapEntry> : new vector<BiasMapEntry>;
   }
   static void *newArray_vectorlEBiasMapEntrygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<BiasMapEntry>[nElements] : new vector<BiasMapEntry>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEBiasMapEntrygR(void *p) {
      delete ((vector<BiasMapEntry>*)p);
   }
   static void deleteArray_vectorlEBiasMapEntrygR(void *p) {
      delete [] ((vector<BiasMapEntry>*)p);
   }
   static void destruct_vectorlEBiasMapEntrygR(void *p) {
      typedef vector<BiasMapEntry> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<BiasMapEntry>

namespace ROOTDict {
   void vectorlEInterpolator2DcLcLcirclegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEInterpolator2DcLcLcirclegR_Dictionary();
   static void *new_vectorlEInterpolator2DcLcLcirclegR(void *p = 0);
   static void *newArray_vectorlEInterpolator2DcLcLcirclegR(Long_t size, void *p);
   static void delete_vectorlEInterpolator2DcLcLcirclegR(void *p);
   static void deleteArray_vectorlEInterpolator2DcLcLcirclegR(void *p);
   static void destruct_vectorlEInterpolator2DcLcLcirclegR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Interpolator2D::circle>*)
   {
      vector<Interpolator2D::circle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Interpolator2D::circle>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Interpolator2D::circle>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<Interpolator2D::circle>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEInterpolator2DcLcLcirclegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Interpolator2D::circle>) );
      instance.SetNew(&new_vectorlEInterpolator2DcLcLcirclegR);
      instance.SetNewArray(&newArray_vectorlEInterpolator2DcLcLcirclegR);
      instance.SetDelete(&delete_vectorlEInterpolator2DcLcLcirclegR);
      instance.SetDeleteArray(&deleteArray_vectorlEInterpolator2DcLcLcirclegR);
      instance.SetDestructor(&destruct_vectorlEInterpolator2DcLcLcirclegR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Interpolator2D::circle> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Interpolator2D::circle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEInterpolator2DcLcLcirclegR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Interpolator2D::circle>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEInterpolator2DcLcLcirclegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Interpolator2D::circle> : new vector<Interpolator2D::circle>;
   }
   static void *newArray_vectorlEInterpolator2DcLcLcirclegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Interpolator2D::circle>[nElements] : new vector<Interpolator2D::circle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEInterpolator2DcLcLcirclegR(void *p) {
      delete ((vector<Interpolator2D::circle>*)p);
   }
   static void deleteArray_vectorlEInterpolator2DcLcLcirclegR(void *p) {
      delete [] ((vector<Interpolator2D::circle>*)p);
   }
   static void destruct_vectorlEInterpolator2DcLcLcirclegR(void *p) {
      typedef vector<Interpolator2D::circle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Interpolator2D::circle>

namespace ROOTDict {
   void vectorlEInterpolator2DcLcLpointgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEInterpolator2DcLcLpointgR_Dictionary();
   static void *new_vectorlEInterpolator2DcLcLpointgR(void *p = 0);
   static void *newArray_vectorlEInterpolator2DcLcLpointgR(Long_t size, void *p);
   static void delete_vectorlEInterpolator2DcLcLpointgR(void *p);
   static void deleteArray_vectorlEInterpolator2DcLcLpointgR(void *p);
   static void destruct_vectorlEInterpolator2DcLcLpointgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Interpolator2D::point>*)
   {
      vector<Interpolator2D::point> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Interpolator2D::point>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Interpolator2D::point>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<Interpolator2D::point>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEInterpolator2DcLcLpointgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Interpolator2D::point>) );
      instance.SetNew(&new_vectorlEInterpolator2DcLcLpointgR);
      instance.SetNewArray(&newArray_vectorlEInterpolator2DcLcLpointgR);
      instance.SetDelete(&delete_vectorlEInterpolator2DcLcLpointgR);
      instance.SetDeleteArray(&deleteArray_vectorlEInterpolator2DcLcLpointgR);
      instance.SetDestructor(&destruct_vectorlEInterpolator2DcLcLpointgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Interpolator2D::point> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Interpolator2D::point>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEInterpolator2DcLcLpointgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Interpolator2D::point>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEInterpolator2DcLcLpointgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Interpolator2D::point> : new vector<Interpolator2D::point>;
   }
   static void *newArray_vectorlEInterpolator2DcLcLpointgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Interpolator2D::point>[nElements] : new vector<Interpolator2D::point>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEInterpolator2DcLcLpointgR(void *p) {
      delete ((vector<Interpolator2D::point>*)p);
   }
   static void deleteArray_vectorlEInterpolator2DcLcLpointgR(void *p) {
      delete [] ((vector<Interpolator2D::point>*)p);
   }
   static void destruct_vectorlEInterpolator2DcLcLpointgR(void *p) {
      typedef vector<Interpolator2D::point> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Interpolator2D::point>

namespace ROOTDict {
   void vectorlEInterpolator2DcLcLweightgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEInterpolator2DcLcLweightgR_Dictionary();
   static void *new_vectorlEInterpolator2DcLcLweightgR(void *p = 0);
   static void *newArray_vectorlEInterpolator2DcLcLweightgR(Long_t size, void *p);
   static void delete_vectorlEInterpolator2DcLcLweightgR(void *p);
   static void deleteArray_vectorlEInterpolator2DcLcLweightgR(void *p);
   static void destruct_vectorlEInterpolator2DcLcLweightgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Interpolator2D::weight>*)
   {
      vector<Interpolator2D::weight> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Interpolator2D::weight>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Interpolator2D::weight>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<Interpolator2D::weight>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEInterpolator2DcLcLweightgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Interpolator2D::weight>) );
      instance.SetNew(&new_vectorlEInterpolator2DcLcLweightgR);
      instance.SetNewArray(&newArray_vectorlEInterpolator2DcLcLweightgR);
      instance.SetDelete(&delete_vectorlEInterpolator2DcLcLweightgR);
      instance.SetDeleteArray(&deleteArray_vectorlEInterpolator2DcLcLweightgR);
      instance.SetDestructor(&destruct_vectorlEInterpolator2DcLcLweightgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Interpolator2D::weight> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Interpolator2D::weight>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEInterpolator2DcLcLweightgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Interpolator2D::weight>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEInterpolator2DcLcLweightgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Interpolator2D::weight> : new vector<Interpolator2D::weight>;
   }
   static void *newArray_vectorlEInterpolator2DcLcLweightgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Interpolator2D::weight>[nElements] : new vector<Interpolator2D::weight>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEInterpolator2DcLcLweightgR(void *p) {
      delete ((vector<Interpolator2D::weight>*)p);
   }
   static void deleteArray_vectorlEInterpolator2DcLcLweightgR(void *p) {
      delete [] ((vector<Interpolator2D::weight>*)p);
   }
   static void destruct_vectorlEInterpolator2DcLcLweightgR(void *p) {
      typedef vector<Interpolator2D::weight> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Interpolator2D::weight>

namespace ROOTDict {
   void vectorlEPixelMapEntrygR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEPixelMapEntrygR_Dictionary();
   static void *new_vectorlEPixelMapEntrygR(void *p = 0);
   static void *newArray_vectorlEPixelMapEntrygR(Long_t size, void *p);
   static void delete_vectorlEPixelMapEntrygR(void *p);
   static void deleteArray_vectorlEPixelMapEntrygR(void *p);
   static void destruct_vectorlEPixelMapEntrygR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<PixelMapEntry>*)
   {
      vector<PixelMapEntry> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<PixelMapEntry>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<PixelMapEntry>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<PixelMapEntry>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEPixelMapEntrygR_Dictionary, isa_proxy, 0,
                  sizeof(vector<PixelMapEntry>) );
      instance.SetNew(&new_vectorlEPixelMapEntrygR);
      instance.SetNewArray(&newArray_vectorlEPixelMapEntrygR);
      instance.SetDelete(&delete_vectorlEPixelMapEntrygR);
      instance.SetDeleteArray(&deleteArray_vectorlEPixelMapEntrygR);
      instance.SetDestructor(&destruct_vectorlEPixelMapEntrygR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<PixelMapEntry> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<PixelMapEntry>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEPixelMapEntrygR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<PixelMapEntry>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEPixelMapEntrygR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<PixelMapEntry> : new vector<PixelMapEntry>;
   }
   static void *newArray_vectorlEPixelMapEntrygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<PixelMapEntry>[nElements] : new vector<PixelMapEntry>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEPixelMapEntrygR(void *p) {
      delete ((vector<PixelMapEntry>*)p);
   }
   static void deleteArray_vectorlEPixelMapEntrygR(void *p) {
      delete [] ((vector<PixelMapEntry>*)p);
   }
   static void destruct_vectorlEPixelMapEntrygR(void *p) {
      typedef vector<PixelMapEntry> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<PixelMapEntry>

namespace ROOTDict {
   void vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR_Dictionary();
   static void *new_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(void *p);
   static void destruct_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >*)
   {
      vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >) );
      instance.SetNew(&new_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > > : new vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >;
   }
   static void *newArray_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >[nElements] : new vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(void *p) {
      delete ((vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >*)p);
   }
   static void deleteArray_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(void *p) {
      delete [] ((vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >*)p);
   }
   static void destruct_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetgRsPgRsPgR(void *p) {
      typedef vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget> > >

namespace ROOTDict {
   void vectorlEchargR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEchargR_Dictionary();
   static void *new_vectorlEchargR(void *p = 0);
   static void *newArray_vectorlEchargR(Long_t size, void *p);
   static void delete_vectorlEchargR(void *p);
   static void deleteArray_vectorlEchargR(void *p);
   static void destruct_vectorlEchargR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<char>*)
   {
      vector<char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<char>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<char>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<char>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEchargR_Dictionary, isa_proxy, 0,
                  sizeof(vector<char>) );
      instance.SetNew(&new_vectorlEchargR);
      instance.SetNewArray(&newArray_vectorlEchargR);
      instance.SetDelete(&delete_vectorlEchargR);
      instance.SetDeleteArray(&deleteArray_vectorlEchargR);
      instance.SetDestructor(&destruct_vectorlEchargR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<char> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEchargR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<char>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEchargR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<char> : new vector<char>;
   }
   static void *newArray_vectorlEchargR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<char>[nElements] : new vector<char>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEchargR(void *p) {
      delete ((vector<char>*)p);
   }
   static void deleteArray_vectorlEchargR(void *p) {
      delete [] ((vector<char>*)p);
   }
   static void destruct_vectorlEchargR(void *p) {
      typedef vector<char> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<char>

namespace ROOTDict {
   void vectorlEofitscLcLKeygR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEofitscLcLKeygR_Dictionary();
   static void *new_vectorlEofitscLcLKeygR(void *p = 0);
   static void *newArray_vectorlEofitscLcLKeygR(Long_t size, void *p);
   static void delete_vectorlEofitscLcLKeygR(void *p);
   static void deleteArray_vectorlEofitscLcLKeygR(void *p);
   static void destruct_vectorlEofitscLcLKeygR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<ofits::Key>*)
   {
      vector<ofits::Key> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ofits::Key>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ofits::Key>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<ofits::Key>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEofitscLcLKeygR_Dictionary, isa_proxy, 0,
                  sizeof(vector<ofits::Key>) );
      instance.SetNew(&new_vectorlEofitscLcLKeygR);
      instance.SetNewArray(&newArray_vectorlEofitscLcLKeygR);
      instance.SetDelete(&delete_vectorlEofitscLcLKeygR);
      instance.SetDeleteArray(&deleteArray_vectorlEofitscLcLKeygR);
      instance.SetDestructor(&destruct_vectorlEofitscLcLKeygR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<ofits::Key> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ofits::Key>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEofitscLcLKeygR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<ofits::Key>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEofitscLcLKeygR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ofits::Key> : new vector<ofits::Key>;
   }
   static void *newArray_vectorlEofitscLcLKeygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ofits::Key>[nElements] : new vector<ofits::Key>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEofitscLcLKeygR(void *p) {
      delete ((vector<ofits::Key>*)p);
   }
   static void deleteArray_vectorlEofitscLcLKeygR(void *p) {
      delete [] ((vector<ofits::Key>*)p);
   }
   static void destruct_vectorlEofitscLcLKeygR(void *p) {
      typedef vector<ofits::Key> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<ofits::Key>

namespace ROOTDict {
   void vectorlEpairlEdoublecOdoublegRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEpairlEdoublecOdoublegRsPgR_Dictionary();
   static void *new_vectorlEpairlEdoublecOdoublegRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEdoublecOdoublegRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEdoublecOdoublegRsPgR(void *p);
   static void deleteArray_vectorlEpairlEdoublecOdoublegRsPgR(void *p);
   static void destruct_vectorlEpairlEdoublecOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<double,double> >*)
   {
      vector<pair<double,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<double,double> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<double,double> >", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<pair<double,double> >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEpairlEdoublecOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<double,double> >) );
      instance.SetNew(&new_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEdoublecOdoublegRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<pair<double,double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<double,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEpairlEdoublecOdoublegRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<pair<double,double> >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEpairlEdoublecOdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<double,double> > : new vector<pair<double,double> >;
   }
   static void *newArray_vectorlEpairlEdoublecOdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<double,double> >[nElements] : new vector<pair<double,double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEdoublecOdoublegRsPgR(void *p) {
      delete ((vector<pair<double,double> >*)p);
   }
   static void deleteArray_vectorlEpairlEdoublecOdoublegRsPgR(void *p) {
      delete [] ((vector<pair<double,double> >*)p);
   }
   static void destruct_vectorlEpairlEdoublecOdoublegRsPgR(void *p) {
      typedef vector<pair<double,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<pair<double,double> >

namespace ROOTDict {
   void vectorlEpairlElongcOlonggRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEpairlElongcOlonggRsPgR_Dictionary();
   static void *new_vectorlEpairlElongcOlonggRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlElongcOlonggRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlElongcOlonggRsPgR(void *p);
   static void deleteArray_vectorlEpairlElongcOlonggRsPgR(void *p);
   static void destruct_vectorlEpairlElongcOlonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<long,long> >*)
   {
      vector<pair<long,long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<long,long> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<long,long> >", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<pair<long,long> >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEpairlElongcOlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<long,long> >) );
      instance.SetNew(&new_vectorlEpairlElongcOlonggRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlElongcOlonggRsPgR);
      instance.SetDelete(&delete_vectorlEpairlElongcOlonggRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlElongcOlonggRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlElongcOlonggRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<pair<long,long> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<long,long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEpairlElongcOlonggRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<pair<long,long> >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEpairlElongcOlonggRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<long,long> > : new vector<pair<long,long> >;
   }
   static void *newArray_vectorlEpairlElongcOlonggRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<long,long> >[nElements] : new vector<pair<long,long> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlElongcOlonggRsPgR(void *p) {
      delete ((vector<pair<long,long> >*)p);
   }
   static void deleteArray_vectorlEpairlElongcOlonggRsPgR(void *p) {
      delete [] ((vector<pair<long,long> >*)p);
   }
   static void destruct_vectorlEpairlElongcOlonggRsPgR(void *p) {
      typedef vector<pair<long,long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<pair<long,long> >

namespace ROOTDict {
   void vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR_Dictionary();
   static void *new_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(void *p);
   static void deleteArray_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(void *p);
   static void destruct_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<void*,fits::Table::Column> >*)
   {
      vector<pair<void*,fits::Table::Column> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<void*,fits::Table::Column> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<void*,fits::Table::Column> >", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<pair<void*,fits::Table::Column> >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<void*,fits::Table::Column> >) );
      instance.SetNew(&new_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<pair<void*,fits::Table::Column> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<void*,fits::Table::Column> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<pair<void*,fits::Table::Column> >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<void*,fits::Table::Column> > : new vector<pair<void*,fits::Table::Column> >;
   }
   static void *newArray_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pair<void*,fits::Table::Column> >[nElements] : new vector<pair<void*,fits::Table::Column> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(void *p) {
      delete ((vector<pair<void*,fits::Table::Column> >*)p);
   }
   static void deleteArray_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(void *p) {
      delete [] ((vector<pair<void*,fits::Table::Column> >*)p);
   }
   static void destruct_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgR(void *p) {
      typedef vector<pair<void*,fits::Table::Column> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<pair<void*,fits::Table::Column> >

namespace ROOTDict {
   void vectorlEshortgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEshortgR_Dictionary();
   static void *new_vectorlEshortgR(void *p = 0);
   static void *newArray_vectorlEshortgR(Long_t size, void *p);
   static void delete_vectorlEshortgR(void *p);
   static void deleteArray_vectorlEshortgR(void *p);
   static void destruct_vectorlEshortgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<short>*)
   {
      vector<short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<short>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<short>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<short>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEshortgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<short>) );
      instance.SetNew(&new_vectorlEshortgR);
      instance.SetNewArray(&newArray_vectorlEshortgR);
      instance.SetDelete(&delete_vectorlEshortgR);
      instance.SetDeleteArray(&deleteArray_vectorlEshortgR);
      instance.SetDestructor(&destruct_vectorlEshortgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<short> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEshortgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<short>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEshortgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<short> : new vector<short>;
   }
   static void *newArray_vectorlEshortgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<short>[nElements] : new vector<short>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEshortgR(void *p) {
      delete ((vector<short>*)p);
   }
   static void deleteArray_vectorlEshortgR(void *p) {
      delete [] ((vector<short>*)p);
   }
   static void destruct_vectorlEshortgR(void *p) {
      typedef vector<short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<short>

namespace ROOTDict {
   void vectorlEstringgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEstringgR_Dictionary();
   static void *new_vectorlEstringgR(void *p = 0);
   static void *newArray_vectorlEstringgR(Long_t size, void *p);
   static void delete_vectorlEstringgR(void *p);
   static void deleteArray_vectorlEstringgR(void *p);
   static void destruct_vectorlEstringgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<string>*)
   {
      vector<string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<string>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<string>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<string>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEstringgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<string>) );
      instance.SetNew(&new_vectorlEstringgR);
      instance.SetNewArray(&newArray_vectorlEstringgR);
      instance.SetDelete(&delete_vectorlEstringgR);
      instance.SetDeleteArray(&deleteArray_vectorlEstringgR);
      instance.SetDestructor(&destruct_vectorlEstringgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<string> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEstringgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<string>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<string> : new vector<string>;
   }
   static void *newArray_vectorlEstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<string>[nElements] : new vector<string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEstringgR(void *p) {
      delete ((vector<string>*)p);
   }
   static void deleteArray_vectorlEstringgR(void *p) {
      delete [] ((vector<string>*)p);
   }
   static void destruct_vectorlEstringgR(void *p) {
      typedef vector<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<string>

namespace ROOTDict {
   void vectorlEunsignedsPlonggR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEunsignedsPlonggR_Dictionary();
   static void *new_vectorlEunsignedsPlonggR(void *p = 0);
   static void *newArray_vectorlEunsignedsPlonggR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPlonggR(void *p);
   static void deleteArray_vectorlEunsignedsPlonggR(void *p);
   static void destruct_vectorlEunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned long>*)
   {
      vector<unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned long>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<unsigned long>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned long>) );
      instance.SetNew(&new_vectorlEunsignedsPlonggR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPlonggR);
      instance.SetDelete(&delete_vectorlEunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPlonggR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPlonggR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<unsigned long> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEunsignedsPlonggR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<unsigned long>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned long> : new vector<unsigned long>;
   }
   static void *newArray_vectorlEunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned long>[nElements] : new vector<unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPlonggR(void *p) {
      delete ((vector<unsigned long>*)p);
   }
   static void deleteArray_vectorlEunsignedsPlonggR(void *p) {
      delete [] ((vector<unsigned long>*)p);
   }
   static void destruct_vectorlEunsignedsPlonggR(void *p) {
      typedef vector<unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<unsigned long>

namespace ROOTDict {
   void vectorlEunsignedsPshortgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEunsignedsPshortgR_Dictionary();
   static void *new_vectorlEunsignedsPshortgR(void *p = 0);
   static void *newArray_vectorlEunsignedsPshortgR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPshortgR(void *p);
   static void deleteArray_vectorlEunsignedsPshortgR(void *p);
   static void destruct_vectorlEunsignedsPshortgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned short>*)
   {
      vector<unsigned short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned short>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned short>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<unsigned short>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEunsignedsPshortgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned short>) );
      instance.SetNew(&new_vectorlEunsignedsPshortgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPshortgR);
      instance.SetDelete(&delete_vectorlEunsignedsPshortgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPshortgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPshortgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<unsigned short> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<unsigned short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEunsignedsPshortgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<unsigned short>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPshortgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned short> : new vector<unsigned short>;
   }
   static void *newArray_vectorlEunsignedsPshortgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned short>[nElements] : new vector<unsigned short>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPshortgR(void *p) {
      delete ((vector<unsigned short>*)p);
   }
   static void deleteArray_vectorlEunsignedsPshortgR(void *p) {
      delete [] ((vector<unsigned short>*)p);
   }
   static void destruct_vectorlEunsignedsPshortgR(void *p) {
      typedef vector<unsigned short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<unsigned short>

namespace ROOTDict {
   void vectorlEvectorlEchargRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEchargRsPgR_Dictionary();
   static void *new_vectorlEvectorlEchargRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEchargRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEchargRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEchargRsPgR(void *p);
   static void destruct_vectorlEvectorlEchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<char> >*)
   {
      vector<vector<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<char> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<char> >", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<char> >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<char> >) );
      instance.SetNew(&new_vectorlEvectorlEchargRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEchargRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEchargRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEchargRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEchargRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<vector<char> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEchargRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<vector<char> >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEchargRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<char> > : new vector<vector<char> >;
   }
   static void *newArray_vectorlEvectorlEchargRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<char> >[nElements] : new vector<vector<char> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEchargRsPgR(void *p) {
      delete ((vector<vector<char> >*)p);
   }
   static void deleteArray_vectorlEvectorlEchargRsPgR(void *p) {
      delete [] ((vector<vector<char> >*)p);
   }
   static void destruct_vectorlEvectorlEchargRsPgR(void *p) {
      typedef vector<vector<char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<vector<char> >

namespace ROOTDict {
   void vectorlEvectorlEpairlElongcOlonggRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEpairlElongcOlonggRsPgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<pair<long,long> > >*)
   {
      vector<vector<pair<long,long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<pair<long,long> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<pair<long,long> > >", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<pair<long,long> > >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEpairlElongcOlonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<pair<long,long> > >) );
      instance.SetNew(&new_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<vector<pair<long,long> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<pair<long,long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEpairlElongcOlonggRsPgRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<vector<pair<long,long> > >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<pair<long,long> > > : new vector<vector<pair<long,long> > >;
   }
   static void *newArray_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<pair<long,long> > >[nElements] : new vector<vector<pair<long,long> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(void *p) {
      delete ((vector<vector<pair<long,long> > >*)p);
   }
   static void deleteArray_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(void *p) {
      delete [] ((vector<vector<pair<long,long> > >*)p);
   }
   static void destruct_vectorlEvectorlEpairlElongcOlonggRsPgRsPgR(void *p) {
      typedef vector<vector<pair<long,long> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<vector<pair<long,long> > >

namespace ROOTDict {
   void vectorlEvectorlEunsignedsPlonggRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEunsignedsPlonggRsPgR_Dictionary();
   static void *new_vectorlEvectorlEunsignedsPlonggRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEunsignedsPlonggRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEunsignedsPlonggRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEunsignedsPlonggRsPgR(void *p);
   static void destruct_vectorlEvectorlEunsignedsPlonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<unsigned long> >*)
   {
      vector<vector<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<unsigned long> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<unsigned long> >", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<unsigned long> >), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<unsigned long> >) );
      instance.SetNew(&new_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<vector<unsigned long> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEunsignedsPlonggRsPgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<vector<unsigned long> >*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEunsignedsPlonggRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<unsigned long> > : new vector<vector<unsigned long> >;
   }
   static void *newArray_vectorlEvectorlEunsignedsPlonggRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<unsigned long> >[nElements] : new vector<vector<unsigned long> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEunsignedsPlonggRsPgR(void *p) {
      delete ((vector<vector<unsigned long> >*)p);
   }
   static void deleteArray_vectorlEvectorlEunsignedsPlonggRsPgR(void *p) {
      delete [] ((vector<vector<unsigned long> >*)p);
   }
   static void destruct_vectorlEvectorlEunsignedsPlonggRsPgR(void *p) {
      typedef vector<vector<unsigned long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<vector<unsigned long> >

namespace ROOTDict {
   void vectorlEzofitscLcLCatalogEntrygR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEzofitscLcLCatalogEntrygR_Dictionary();
   static void *new_vectorlEzofitscLcLCatalogEntrygR(void *p = 0);
   static void *newArray_vectorlEzofitscLcLCatalogEntrygR(Long_t size, void *p);
   static void delete_vectorlEzofitscLcLCatalogEntrygR(void *p);
   static void deleteArray_vectorlEzofitscLcLCatalogEntrygR(void *p);
   static void destruct_vectorlEzofitscLcLCatalogEntrygR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<zofits::CatalogEntry>*)
   {
      vector<zofits::CatalogEntry> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<zofits::CatalogEntry>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<zofits::CatalogEntry>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<zofits::CatalogEntry>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEzofitscLcLCatalogEntrygR_Dictionary, isa_proxy, 0,
                  sizeof(vector<zofits::CatalogEntry>) );
      instance.SetNew(&new_vectorlEzofitscLcLCatalogEntrygR);
      instance.SetNewArray(&newArray_vectorlEzofitscLcLCatalogEntrygR);
      instance.SetDelete(&delete_vectorlEzofitscLcLCatalogEntrygR);
      instance.SetDeleteArray(&deleteArray_vectorlEzofitscLcLCatalogEntrygR);
      instance.SetDestructor(&destruct_vectorlEzofitscLcLCatalogEntrygR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<zofits::CatalogEntry> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<zofits::CatalogEntry>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEzofitscLcLCatalogEntrygR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<zofits::CatalogEntry>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEzofitscLcLCatalogEntrygR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<zofits::CatalogEntry> : new vector<zofits::CatalogEntry>;
   }
   static void *newArray_vectorlEzofitscLcLCatalogEntrygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<zofits::CatalogEntry>[nElements] : new vector<zofits::CatalogEntry>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEzofitscLcLCatalogEntrygR(void *p) {
      delete ((vector<zofits::CatalogEntry>*)p);
   }
   static void deleteArray_vectorlEzofitscLcLCatalogEntrygR(void *p) {
      delete [] ((vector<zofits::CatalogEntry>*)p);
   }
   static void destruct_vectorlEzofitscLcLCatalogEntrygR(void *p) {
      typedef vector<zofits::CatalogEntry> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<zofits::CatalogEntry>

namespace ROOTDict {
   void vectorlEzofitscLcLCompressedColumngR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEzofitscLcLCompressedColumngR_Dictionary();
   static void *new_vectorlEzofitscLcLCompressedColumngR(void *p = 0);
   static void *newArray_vectorlEzofitscLcLCompressedColumngR(Long_t size, void *p);
   static void delete_vectorlEzofitscLcLCompressedColumngR(void *p);
   static void deleteArray_vectorlEzofitscLcLCompressedColumngR(void *p);
   static void destruct_vectorlEzofitscLcLCompressedColumngR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<zofits::CompressedColumn>*)
   {
      vector<zofits::CompressedColumn> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<zofits::CompressedColumn>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<zofits::CompressedColumn>", -2, "/home/sebastian/CERN_root/build_5.34.36/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<zofits::CompressedColumn>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEzofitscLcLCompressedColumngR_Dictionary, isa_proxy, 0,
                  sizeof(vector<zofits::CompressedColumn>) );
      instance.SetNew(&new_vectorlEzofitscLcLCompressedColumngR);
      instance.SetNewArray(&newArray_vectorlEzofitscLcLCompressedColumngR);
      instance.SetDelete(&delete_vectorlEzofitscLcLCompressedColumngR);
      instance.SetDeleteArray(&deleteArray_vectorlEzofitscLcLCompressedColumngR);
      instance.SetDestructor(&destruct_vectorlEzofitscLcLCompressedColumngR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<zofits::CompressedColumn> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<zofits::CompressedColumn>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEzofitscLcLCompressedColumngR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<zofits::CompressedColumn>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEzofitscLcLCompressedColumngR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<zofits::CompressedColumn> : new vector<zofits::CompressedColumn>;
   }
   static void *newArray_vectorlEzofitscLcLCompressedColumngR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<zofits::CompressedColumn>[nElements] : new vector<zofits::CompressedColumn>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEzofitscLcLCompressedColumngR(void *p) {
      delete ((vector<zofits::CompressedColumn>*)p);
   }
   static void deleteArray_vectorlEzofitscLcLCompressedColumngR(void *p) {
      delete [] ((vector<zofits::CompressedColumn>*)p);
   }
   static void destruct_vectorlEzofitscLcLCompressedColumngR(void *p) {
      typedef vector<zofits::CompressedColumn> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<zofits::CompressedColumn>

/********************************************************
* MCint.cc
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableMCint();

extern "C" void G__set_cpp_environmentMCint() {
  G__cpp_reset_tagtableMCint();
}
#include <new>
extern "C" int G__cpp_dllrevMCint() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* FITS */
static int G__MCint_107_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) FITS::IsReservedKeyWord(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_107_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = FITS::CommentFromType((char) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_107_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) FITS::SizeFromType((char) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}


/* FITS::Compression */
static int G__MCint_112_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FITS::Compression* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FITS::Compression(*(vector<uint16_t>*) libp->para[0].ref, *(FITS::RowOrdering_t*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) FITS::Compression(*(vector<uint16_t>*) libp->para[0].ref, *(FITS::RowOrdering_t*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FITS::Compression(*(vector<uint16_t>*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) FITS::Compression(*(vector<uint16_t>*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_112_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FITS::Compression* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FITS::Compression(*(FITS::CompressionProcess_t*) libp->para[0].ref, *(FITS::RowOrdering_t*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) FITS::Compression(*(FITS::CompressionProcess_t*) libp->para[0].ref, *(FITS::RowOrdering_t*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FITS::Compression(*(FITS::CompressionProcess_t*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) FITS::Compression(*(FITS::CompressionProcess_t*) libp->para[0].ref);
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new FITS::Compression[n];
       } else {
         p = new((void*) gvp) FITS::Compression[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new FITS::Compression;
       } else {
         p = new((void*) gvp) FITS::Compression;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_112_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FITS::Compression* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new FITS::Compression(*(int*) G__Intref(&libp->para[0]));
   } else {
     p = new((void*) gvp) FITS::Compression(*(int*) G__Intref(&libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_112_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const FITS::Compression*) G__getstructoffset())->getOrdering());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_112_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const FITS::Compression*) G__getstructoffset())->getSizeOnDisk());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_112_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const FITS::Compression*) G__getstructoffset())->getProc((uint32_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_112_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 114, (long) ((const FITS::Compression*) G__getstructoffset())->getNumProcs());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_112_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((FITS::Compression*) G__getstructoffset())->SetBlockSize((uint64_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_112_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const FITS::Compression*) G__getstructoffset())->Memcpy((char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_112_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FITS::Compression* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FITS::Compression(*(FITS::Compression*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FITS::Compression G__TFITScLcLCompression;
static int G__MCint_112_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FITS::Compression*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FITS::Compression*) (soff+(sizeof(FITS::Compression)*i)))->~G__TFITScLcLCompression();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FITS::Compression*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FITS::Compression*) (soff))->~G__TFITScLcLCompression();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_112_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FITS::Compression* dest = (FITS::Compression*) G__getstructoffset();
   *dest = *(FITS::Compression*) libp->para[0].ref;
   const FITS::Compression& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* izstream */
static int G__MCint_210_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   izstream* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new izstream[n];
     } else {
       p = new((void*) gvp) izstream[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new izstream;
     } else {
       p = new((void*) gvp) izstream;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_izstream));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_210_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   izstream* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new izstream((const char*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) izstream((const char*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_izstream));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_210_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((izstream*) G__getstructoffset())->is_open());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_210_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((izstream*) G__getstructoffset())->open((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_210_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((izstream*) G__getstructoffset())->close();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_210_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letLonglong(result7, 110, (G__int64) ((izstream*) G__getstructoffset())->seekoff((basic_streambuf<char,char_traits<char> >::off_type) G__Longlong(libp->para[0]), (ios_base::seekdir) G__int(libp->para[1])
, (ios_base::openmode) G__int(libp->para[2])));
      break;
   case 2:
      G__letLonglong(result7, 110, (G__int64) ((izstream*) G__getstructoffset())->seekoff((basic_streambuf<char,char_traits<char> >::off_type) G__Longlong(libp->para[0]), (ios_base::seekdir) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_210_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letLonglong(result7, 110, (G__int64) ((izstream*) G__getstructoffset())->seekpos((basic_streambuf<char,char_traits<char> >::pos_type) G__Longlong(libp->para[0]), (ios_base::openmode) G__int(libp->para[1])));
      break;
   case 1:
      G__letLonglong(result7, 110, (G__int64) ((izstream*) G__getstructoffset())->seekpos((basic_streambuf<char,char_traits<char> >::pos_type) G__Longlong(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef izstream G__Tizstream;
static int G__MCint_210_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (izstream*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((izstream*) (soff+(sizeof(izstream)*i)))->~G__Tizstream();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (izstream*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((izstream*) (soff))->~G__Tizstream();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Checksum */
static int G__MCint_211_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Checksum*) G__getstructoffset())->reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Checksum* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Checksum[n];
     } else {
       p = new((void*) gvp) Checksum[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Checksum;
     } else {
       p = new((void*) gvp) Checksum;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_Checksum));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Checksum* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Checksum(*(Checksum*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Checksum(*(Checksum*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_Checksum));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Checksum* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Checksum((uint64_t) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Checksum((uint64_t) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_Checksum));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Checksum*) G__getstructoffset())->val());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Checksum*) G__getstructoffset())->valid());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Checksum*) G__getstructoffset())->HandleCarryBits();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Checksum& obj = ((Checksum*) G__getstructoffset())->operator+=(*(Checksum*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Checksum* pobj;
         const Checksum xobj = ((const Checksum*) G__getstructoffset())->operator+(*((Checksum*) G__int(libp->para[0])));
         pobj = new Checksum(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((Checksum*) G__getstructoffset())->add((const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, (bool) G__int(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 103, (long) ((Checksum*) G__getstructoffset())->add((const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Checksum*) G__getstructoffset())->addLoopSwapping((const uint16_t*) G__int(libp->para[0]), (const uint16_t*) G__int(libp->para[1])
, (uint32_t*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Checksum*) G__getstructoffset())->addLoop((const uint16_t*) G__int(libp->para[0]), (const uint16_t*) G__int(libp->para[1])
, (uint32_t*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((Checksum*) G__getstructoffset())->add(*(vector<char>*) libp->para[0].ref, (bool) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((Checksum*) G__getstructoffset())->add(*(vector<char>*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_211_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const string* pobj;
         const string xobj = ((const Checksum*) G__getstructoffset())->str((bool) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const string* pobj;
         const string xobj = ((const Checksum*) G__getstructoffset())->str();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Checksum G__TChecksum;
static int G__MCint_211_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Checksum*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Checksum*) (soff+(sizeof(Checksum)*i)))->~G__TChecksum();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Checksum*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Checksum*) (soff))->~G__TChecksum();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_211_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Checksum* dest = (Checksum*) G__getstructoffset();
   *dest = *(Checksum*) libp->para[0].ref;
   const Checksum& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* fits */
static int G__MCint_216_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((fits*) G__getstructoffset())->Exception(*(string*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   fits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, (bool) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) fits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, (bool) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fits(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) fits(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fits(*(string*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) fits(*(string*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_fits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   fits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, (bool) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) fits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, (bool) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
     } else {
       p = new((void*) gvp) fits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_fits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   fits* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fits[n];
     } else {
       p = new((void*) gvp) fits[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fits;
     } else {
       p = new((void*) gvp) fits;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_fits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((fits*) G__getstructoffset())->StageRow((size_t) G__int(libp->para[0]), (char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((fits*) G__getstructoffset())->WriteRowToCopyFile((size_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((fits*) G__getstructoffset())->ZeroBufferForChecksum(*(vector<char>*) libp->para[0].ref, (const uint64_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((fits*) G__getstructoffset())->ZeroBufferForChecksum(*(vector<char>*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) ((fits*) G__getstructoffset())->ReadRow((size_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((fits*) G__getstructoffset())->MoveColumnDataToUserSpace((char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, *(fits::Table::Column*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((fits*) G__getstructoffset())->GetRow((size_t) G__int(libp->para[0]), (bool) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((fits*) G__getstructoffset())->GetRow((size_t) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 103, (long) ((fits*) G__getstructoffset())->GetNextRow((bool) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((fits*) G__getstructoffset())->GetNextRow());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((fits*) G__getstructoffset())->SkipNextRow());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) fits::Compare(*(fits::Address*) libp->para[0].ref, *(fits::Address*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((fits*) G__getstructoffset())->EnableAddressExceptions((bool) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((fits*) G__getstructoffset())->EnableAddressExceptions();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((fits*) G__getstructoffset())->DisableAddressExceptions();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((fits*) G__getstructoffset())->SetPtrAddress(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((fits*) G__getstructoffset())->SetPtrAddress(*(string*) libp->para[0].ref, (void*) G__int(libp->para[1])
, (size_t) G__int(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 103, (long) ((fits*) G__getstructoffset())->SetPtrAddress(*(string*) libp->para[0].ref, (void*) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const fits*) G__getstructoffset())->HasKey(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const fits*) G__getstructoffset())->HasColumn(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const fits::Table::Columns& obj = ((const fits*) G__getstructoffset())->GetColumns();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const fits::Table::SortedColumns& obj = ((const fits*) G__getstructoffset())->GetSortedColumns();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const fits::Table::Keys& obj = ((const fits*) G__getstructoffset())->GetKeys();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) ((const fits*) G__getstructoffset())->GetInt(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const fits*) G__getstructoffset())->GetUInt(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const fits*) G__getstructoffset())->GetFloat(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const fits*) G__getstructoffset())->GetStr(*(string*) libp->para[0].ref);
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const fits*) G__getstructoffset())->GetN(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const fits*) G__getstructoffset())->GetRow());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const fits*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((const fits*) G__getstructoffset())->PrintKeys((bool) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((const fits*) G__getstructoffset())->PrintKeys();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const fits*) G__getstructoffset())->PrintColumns();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const fits*) G__getstructoffset())->IsHeaderOk());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const fits*) G__getstructoffset())->IsFileOk());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const fits*) G__getstructoffset())->IsCompressedFITS());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const fits*) G__getstructoffset())->GetNumRows());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const fits*) G__getstructoffset())->GetBytesPerRow());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_216_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<std::string>& obj = ((const fits*) G__getstructoffset())->GetTables();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef fits G__Tfits;
static int G__MCint_216_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (fits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((fits*) (soff+(sizeof(fits)*i)))->~G__Tfits();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (fits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((fits*) (soff))->~G__Tfits();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ofits */
static int G__MCint_256_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ofits* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ofits[n];
     } else {
       p = new((void*) gvp) ofits[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ofits;
     } else {
       p = new((void*) gvp) ofits;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ofits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ofits* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ofits((const char*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ofits((const char*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ofits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->is_open());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ofits*) G__getstructoffset())->is_open());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((ofits*) G__getstructoffset())->open((const char*) G__int(libp->para[0]), (bool) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ofits*) G__getstructoffset())->open((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((ofits*) G__getstructoffset())->open(*(string*) libp->para[0].ref, (bool) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ofits*) G__getstructoffset())->open(*(string*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ofits*) G__getstructoffset())->AllowCommentsTrimming((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetKeyComment(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->CopyKeys(*(fits*) libp->para[0].ref, (bool) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->CopyKeys(*(fits*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetRaw(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetBool(*(string*) libp->para[0].ref, (bool) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetBool(*(string*) libp->para[0].ref, (bool) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddEmpty(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddEmpty(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetStr(*(string*) libp->para[0].ref, *((string*) G__int(libp->para[1]))
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetStr(*(string*) libp->para[0].ref, *((string*) G__int(libp->para[1]))));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetInt(*(string*) libp->para[0].ref, (int64_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetInt(*(string*) libp->para[0].ref, (int64_t) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetFloat(*(string*) libp->para[0].ref, (double) G__double(libp->para[1])
, (int) G__int(libp->para[2]), *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetFloat(*(string*) libp->para[0].ref, (double) G__double(libp->para[1])
, (int) G__int(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetFloat(*(string*) libp->para[0].ref, (double) G__double(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetFloat(*(string*) libp->para[0].ref, (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetHex(*(string*) libp->para[0].ref, (uint64_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->SetHex(*(string*) libp->para[0].ref, (uint64_t) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddComment(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddHistory(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ofits*) G__getstructoffset())->End();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumn((uint32_t) G__int(libp->para[0]), (char) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref, (bool) G__int(libp->para[5])));
      break;
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumn((uint32_t) G__int(libp->para[0]), (char) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumn((uint32_t) G__int(libp->para[0]), (char) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 7:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumn(
*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, (char) G__int(libp->para[2]), *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref, *(string*) libp->para[5].ref
, (bool) G__int(libp->para[6])));
      break;
   case 6:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumn(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, (char) G__int(libp->para[2]), *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref, *(string*) libp->para[5].ref));
      break;
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumn(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, (char) G__int(libp->para[2]), *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool((uint32_t) G__int(libp->para[0]), *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(string*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref
, *(string*) libp->para[4].ref));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(FITS::Compression*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, *(string*) libp->para[2].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnShort(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnInt(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnLong(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnFloat(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnDouble(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnChar(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnByte(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->AddColumnBool(*(FITS::Compression*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Checksum* pobj;
         Checksum xobj = ((ofits*) G__getstructoffset())->WriteHeader(*(ostream*) libp->para[0].ref);
         pobj = new Checksum(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Checksum* pobj;
         Checksum xobj = ((ofits*) G__getstructoffset())->WriteHeader();
         pobj = new Checksum(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ofits*) G__getstructoffset())->FlushHeader();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Checksum* pobj;
         Checksum xobj = ((ofits*) G__getstructoffset())->WriteFitsHeader();
         pobj = new Checksum(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->WriteDrsOffsetsTable());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->WriteCatalog());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_64(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->WriteTableHeader((const char*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->WriteTableHeader());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_65(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ofits*) G__getstructoffset())->GetBytesPerRow());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_66(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->WriteRow((void*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, (bool) G__int(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->WriteRow((void*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ofits*) G__getstructoffset())->FlushNumRows();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const ofits*) G__getstructoffset())->GetNumRows());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ofits*) G__getstructoffset())->AlignTo2880Bytes();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Checksum* pobj;
         Checksum xobj = ((ofits*) G__getstructoffset())->UpdateHeaderChecksum();
         pobj = new Checksum(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ofits*) G__getstructoffset())->close());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         pair<std::string,int>* pobj;
         pair<std::string,int> xobj = ((ofits*) G__getstructoffset())->GetChecksumData();
         pobj = new pair<std::string,int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_256_0_73(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ofits*) G__getstructoffset())->SetDefaultKeys();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ofits G__Tofits;
static int G__MCint_256_0_74(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ofits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ofits*) (soff+(sizeof(ofits)*i)))->~G__Tofits();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ofits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ofits*) (soff))->~G__Tofits();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Huffman */
static int G__MCint_269_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) Huffman::numbytes_from_numbits((unsigned long) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_269_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) Huffman::Encode(*(string*) libp->para[0].ref, (const uint16_t*) G__int(libp->para[1])
, (size_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_269_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) Huffman::Decode((const uint8_t*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, *(vector<uint16_t>*) libp->para[2].ref));
   return(1 || funcname || hash || result7 || libp) ;
}


/* zofits */
static int G__MCint_285_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) zofits::DefaultNumThreads(*(uint32_t*) G__UIntref(&libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) zofits::DefaultNumThreads());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) zofits::DefaultMaxMemory(*(uint32_t*) G__UIntref(&libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) zofits::DefaultMaxMemory());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) zofits::DefaultMaxNumTiles(*(uint32_t*) G__UIntref(&libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) zofits::DefaultMaxNumTiles());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) zofits::DefaultNumRowsPerTile(*(uint32_t*) G__UIntref(&libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) zofits::DefaultNumRowsPerTile());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   zofits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits(
(uint32_t) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) zofits(
(uint32_t) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits((uint32_t) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) zofits((uint32_t) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits((uint32_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) zofits((uint32_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new zofits[n];
       } else {
         p = new((void*) gvp) zofits[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new zofits;
       } else {
         p = new((void*) gvp) zofits;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_zofits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   zofits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits(
(const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]), (uint32_t) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) zofits(
(const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]), (uint32_t) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits(
(const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) zofits(
(const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits((const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) zofits((const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) zofits((const char*) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_zofits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   zofits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits(
*(string*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]), (uint32_t) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) zofits(
*(string*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]), (uint32_t) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits(
*(string*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) zofits(
*(string*) libp->para[0].ref, (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits(*(string*) libp->para[0].ref, (uint32_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) zofits(*(string*) libp->para[0].ref, (uint32_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zofits(*(string*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) zofits(*(string*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_zofits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((zofits*) G__getstructoffset())->InitMemberVariables((const uint32_t) G__int(libp->para[0]), (const uint32_t) G__int(libp->para[1])
, (const uint64_t) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((zofits*) G__getstructoffset())->InitMemberVariables((const uint32_t) G__int(libp->para[0]), (const uint32_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((zofits*) G__getstructoffset())->InitMemberVariables((const uint32_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((zofits*) G__getstructoffset())->InitMemberVariables();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((zofits*) G__getstructoffset())->DrsOffsetCalibrate((char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const zofits::CatalogRow& obj = ((zofits*) G__getstructoffset())->AddOneCatalogRow();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         zofits::CompressionTarget* pobj;
         zofits::CompressionTarget xobj = ((zofits*) G__getstructoffset())->InitNextCompression();
         pobj = new zofits::CompressionTarget(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((zofits*) G__getstructoffset())->ShrinkCatalog());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const zofits*) G__getstructoffset())->GetNumThreads());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((zofits*) G__getstructoffset())->SetNumThreads((uint32_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const zofits*) G__getstructoffset())->GetNumTiles());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_285_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((zofits*) G__getstructoffset())->SetNumTiles((uint32_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef zofits G__Tzofits;
static int G__MCint_285_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (zofits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((zofits*) (soff+(sizeof(zofits)*i)))->~G__Tzofits();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (zofits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((zofits*) (soff))->~G__Tzofits();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DrsCalibrateTime */
static int G__MCint_336_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DrsCalibrateTime* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrsCalibrateTime[n];
     } else {
       p = new((void*) gvp) DrsCalibrateTime[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrsCalibrateTime;
     } else {
       p = new((void*) gvp) DrsCalibrateTime;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DrsCalibrateTime* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new DrsCalibrateTime(*(DrsCalibrateTime*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) DrsCalibrateTime(*(DrsCalibrateTime*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const DrsCalibrateTime*) G__getstructoffset())->Sum((uint32_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const DrsCalibrateTime*) G__getstructoffset())->W((uint32_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((DrsCalibrateTime*) G__getstructoffset())->InitSize((uint16_t) G__int(libp->para[0]), (uint16_t) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((DrsCalibrateTime*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((DrsCalibrateTime*) G__getstructoffset())->AddT((float*) G__int(libp->para[0]), (const int16_t*) G__int(libp->para[1])
, (char) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((DrsCalibrateTime*) G__getstructoffset())->AddT((float*) G__int(libp->para[0]), (const int16_t*) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((DrsCalibrateTime*) G__getstructoffset())->FillEmptyBins();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrsCalibrateTime* pobj;
         const DrsCalibrateTime xobj = ((const DrsCalibrateTime*) G__getstructoffset())->GetComplete();
         pobj = new DrsCalibrateTime(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((DrsCalibrateTime*) G__getstructoffset())->CalcResult();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrsCalibrateTime* pobj;
         const DrsCalibrateTime xobj = ((const DrsCalibrateTime*) G__getstructoffset())->GetResult();
         pobj = new DrsCalibrateTime(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const DrsCalibrateTime*) G__getstructoffset())->Offset((uint32_t) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_336_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const DrsCalibrateTime*) G__getstructoffset())->Calib((uint32_t) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DrsCalibrateTime G__TDrsCalibrateTime;
static int G__MCint_336_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DrsCalibrateTime*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DrsCalibrateTime*) (soff+(sizeof(DrsCalibrateTime)*i)))->~G__TDrsCalibrateTime();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DrsCalibrateTime*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DrsCalibrateTime*) (soff))->~G__TDrsCalibrateTime();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_336_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DrsCalibrateTime* dest = (DrsCalibrateTime*) G__getstructoffset();
   *dest = *(DrsCalibrateTime*) libp->para[0].ref;
   const DrsCalibrateTime& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* factofits */
static int G__MCint_351_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   factofits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factofits(
(uint32_t) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) factofits(
(uint32_t) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factofits((uint32_t) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) factofits((uint32_t) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factofits((uint32_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) factofits((uint32_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new factofits[n];
       } else {
         p = new((void*) gvp) factofits[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new factofits;
       } else {
         p = new((void*) gvp) factofits;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_factofits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_351_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   factofits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factofits(
(const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]), (uint32_t) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) factofits(
(const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]), (uint32_t) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factofits(
(const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) factofits(
(const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1])
, (uint32_t) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factofits((const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) factofits((const char*) G__int(libp->para[0]), (uint32_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factofits((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) factofits((const char*) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_factofits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_351_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((factofits*) G__getstructoffset())->IsOffsetCalibration());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_351_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((factofits*) G__getstructoffset())->SetDrsCalibration(*(vector<float>*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_351_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((factofits*) G__getstructoffset())->SetDrsCalibration(*(vector<int16_t>*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_351_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((factofits*) G__getstructoffset())->SetDrsCalibration(*(DrsCalibration*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef factofits G__Tfactofits;
static int G__MCint_351_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (factofits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((factofits*) (soff+(sizeof(factofits)*i)))->~G__Tfactofits();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (factofits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((factofits*) (soff))->~G__Tfactofits();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* zfits */
static int G__MCint_356_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   zfits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, (bool) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) zfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, (bool) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zfits(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) zfits(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zfits(*(string*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) zfits(*(string*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_zfits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_356_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   zfits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, (bool) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) zfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, (bool) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new zfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
     } else {
       p = new((void*) gvp) zfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_zfits));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef zfits G__Tzfits;
static int G__MCint_356_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (zfits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((zfits*) (soff+(sizeof(zfits)*i)))->~G__Tzfits();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (zfits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((zfits*) (soff))->~G__Tzfits();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* factfits */
static int G__MCint_374_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   factfits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, (bool) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) factfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, (bool) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factfits(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) factfits(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factfits(*(string*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) factfits(*(string*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_factfits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_374_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   factfits* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, (bool) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) factfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, (bool) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new factfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
     } else {
       p = new((void*) gvp) factfits(
*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_factfits));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_374_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<int16_t>& obj = ((const factfits*) G__getstructoffset())->GetOffsetCalibration();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef factfits G__Tfactfits;
static int G__MCint_374_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (factfits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((factfits*) (soff+(sizeof(factfits)*i)))->~G__Tfactfits();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (factfits*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((factfits*) (soff))->~G__Tfactfits();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PixelMapEntry */
static int G__MCint_375_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PixelMapEntry* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PixelMapEntry[n];
     } else {
       p = new((void*) gvp) PixelMapEntry[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PixelMapEntry;
     } else {
       p = new((void*) gvp) PixelMapEntry;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_PixelMapEntry));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const PixelMapEntry*) G__getstructoffset())->crate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const PixelMapEntry*) G__getstructoffset())->board());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const PixelMapEntry*) G__getstructoffset())->patch());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const PixelMapEntry*) G__getstructoffset())->pixel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const PixelMapEntry*) G__getstructoffset())->hw());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const PixelMapEntry*) G__getstructoffset())->group());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const PixelMapEntry*) G__getstructoffset())->count());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const PixelMapEntry*) G__getstructoffset())->hv());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const PixelMapEntry*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_375_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const PixelMapEntry& obj = PixelMapEntry::empty();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_375_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PixelMapEntry* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PixelMapEntry(*(PixelMapEntry*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_PixelMapEntry));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PixelMapEntry G__TPixelMapEntry;
static int G__MCint_375_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PixelMapEntry*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PixelMapEntry*) (soff+(sizeof(PixelMapEntry)*i)))->~G__TPixelMapEntry();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PixelMapEntry*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PixelMapEntry*) (soff))->~G__TPixelMapEntry();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_375_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PixelMapEntry* dest = (PixelMapEntry*) G__getstructoffset();
   *dest = *(PixelMapEntry*) libp->para[0].ref;
   const PixelMapEntry& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PixelMap */
static int G__MCint_376_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PixelMap* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PixelMap[n];
     } else {
       p = new((void*) gvp) PixelMap[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PixelMap;
     } else {
       p = new((void*) gvp) PixelMap;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_PixelMap));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_376_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((PixelMap*) G__getstructoffset())->Read(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_376_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const PixelMapEntry& obj = ((const PixelMap*) G__getstructoffset())->index((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_376_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const PixelMapEntry& obj = ((const PixelMap*) G__getstructoffset())->cbpx((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_376_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const PixelMapEntry& obj = ((const PixelMap*) G__getstructoffset())->cbpx((int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (int) G__int(libp->para[2]), (int) G__int(libp->para[3]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_376_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const PixelMapEntry& obj = ((const PixelMap*) G__getstructoffset())->hw((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_376_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const PixelMapEntry& obj = ((const PixelMap*) G__getstructoffset())->hv((int) G__int(libp->para[0]), (int) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_376_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const PixelMapEntry& obj = ((const PixelMap*) G__getstructoffset())->hv((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_376_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PixelMap* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PixelMap(*(PixelMap*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_PixelMap));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PixelMap G__TPixelMap;
static int G__MCint_376_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PixelMap*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PixelMap*) (soff+(sizeof(PixelMap)*i)))->~G__TPixelMap();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PixelMap*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PixelMap*) (soff))->~G__TPixelMap();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_376_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PixelMap* dest = (PixelMap*) G__getstructoffset();
   const PixelMap& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* BiasMapEntry */
static int G__MCint_381_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BiasMapEntry* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BiasMapEntry[n];
     } else {
       p = new((void*) gvp) BiasMapEntry[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BiasMapEntry;
     } else {
       p = new((void*) gvp) BiasMapEntry;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_BiasMapEntry));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_381_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const BiasMapEntry*) G__getstructoffset())->hv());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_381_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const BiasMapEntry*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_381_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const BiasMapEntry& obj = BiasMapEntry::empty();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_381_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   BiasMapEntry* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new BiasMapEntry(*(BiasMapEntry*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_BiasMapEntry));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef BiasMapEntry G__TBiasMapEntry;
static int G__MCint_381_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (BiasMapEntry*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((BiasMapEntry*) (soff+(sizeof(BiasMapEntry)*i)))->~G__TBiasMapEntry();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (BiasMapEntry*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((BiasMapEntry*) (soff))->~G__TBiasMapEntry();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_381_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BiasMapEntry* dest = (BiasMapEntry*) G__getstructoffset();
   *dest = *(BiasMapEntry*) libp->para[0].ref;
   const BiasMapEntry& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* BiasMap */
static int G__MCint_382_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BiasMap* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BiasMap[n];
     } else {
       p = new((void*) gvp) BiasMap[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new BiasMap;
     } else {
       p = new((void*) gvp) BiasMap;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_BiasMap));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_382_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((BiasMap*) G__getstructoffset())->Read(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_382_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const BiasMapEntry& obj = ((const BiasMap*) G__getstructoffset())->hv((int) G__int(libp->para[0]), (int) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_382_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const BiasMapEntry& obj = ((const BiasMap*) G__getstructoffset())->hv((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_382_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const BiasMapEntry& obj = ((const BiasMap*) G__getstructoffset())->hv(*(PixelMapEntry*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_382_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<float>* pobj;
         const vector<float> xobj = ((const BiasMap*) G__getstructoffset())->Vgapd();
         pobj = new vector<float>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_382_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<float>* pobj;
         const vector<float> xobj = ((const BiasMap*) G__getstructoffset())->Voffset();
         pobj = new vector<float>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_382_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<float>* pobj;
         const vector<float> xobj = ((const BiasMap*) G__getstructoffset())->Vslope();
         pobj = new vector<float>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_382_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   BiasMap* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new BiasMap(*(BiasMap*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_BiasMap));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef BiasMap G__TBiasMap;
static int G__MCint_382_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (BiasMap*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((BiasMap*) (soff+(sizeof(BiasMap)*i)))->~G__TBiasMap();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (BiasMap*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((BiasMap*) (soff))->~G__TBiasMap();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_382_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   BiasMap* dest = (BiasMap*) G__getstructoffset();
   const BiasMap& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Interpolator2D */
static int G__MCint_387_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Interpolator2D* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Interpolator2D[n];
     } else {
       p = new((void*) gvp) Interpolator2D[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Interpolator2D;
     } else {
       p = new((void*) gvp) Interpolator2D;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_Interpolator2D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Interpolator2D* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Interpolator2D(
(int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) Interpolator2D(
(int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_Interpolator2D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Interpolator2D* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Interpolator2D(*(vector<Interpolator2D::vec>*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Interpolator2D(*(vector<Interpolator2D::vec>*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_Interpolator2D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<Interpolator2D::weight>* pobj;
         const vector<Interpolator2D::weight> xobj = ((const Interpolator2D*) G__getstructoffset())->getWeights();
         pobj = new vector<Interpolator2D::weight>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<Interpolator2D::point>* pobj;
         const vector<Interpolator2D::point> xobj = ((const Interpolator2D*) G__getstructoffset())->getInputGrid();
         pobj = new vector<Interpolator2D::point>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<Interpolator2D::point>* pobj;
         const vector<Interpolator2D::point> xobj = ((const Interpolator2D*) G__getstructoffset())->getOutputGrid();
         pobj = new vector<Interpolator2D::point>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<Interpolator2D::vec>* pobj;
         vector<Interpolator2D::vec> xobj = Interpolator2D::ReadGrid(*(string*) libp->para[0].ref);
         pobj = new vector<Interpolator2D::vec>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Interpolator2D*) G__getstructoffset())->SetInputGrid((unsigned int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Interpolator2D*) G__getstructoffset())->SetInputGrid(*(vector<Interpolator2D::vec>*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((Interpolator2D*) G__getstructoffset())->ReadInputGrid(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((Interpolator2D*) G__getstructoffset())->SetOutputGrid((size_t) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((Interpolator2D*) G__getstructoffset())->SetOutputGrid(*(vector<Interpolator2D::vec>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((Interpolator2D*) G__getstructoffset())->ReadOutputGrid(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_387_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double>* pobj;
         const vector<double> xobj = ((const Interpolator2D*) G__getstructoffset())->Interpolate(*(vector<double>*) libp->para[0].ref);
         pobj = new vector<double>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_387_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Interpolator2D* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Interpolator2D(*(Interpolator2D*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_Interpolator2D));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Interpolator2D G__TInterpolator2D;
static int G__MCint_387_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Interpolator2D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Interpolator2D*) (soff+(sizeof(Interpolator2D)*i)))->~G__TInterpolator2D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Interpolator2D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Interpolator2D*) (soff))->~G__TInterpolator2D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_387_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Interpolator2D* dest = (Interpolator2D*) G__getstructoffset();
   *dest = *(Interpolator2D*) libp->para[0].ref;
   const Interpolator2D& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ln_equ_posn */
// automatic default constructor
static int G__MCint_415_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ln_equ_posn *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ln_equ_posn[n];
     } else {
       p = new((void*) gvp) ln_equ_posn[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ln_equ_posn;
     } else {
       p = new((void*) gvp) ln_equ_posn;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ln_equ_posn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_415_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ln_equ_posn* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ln_equ_posn(*(ln_equ_posn*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ln_equ_posn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ln_equ_posn G__Tln_equ_posn;
static int G__MCint_415_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ln_equ_posn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ln_equ_posn*) (soff+(sizeof(ln_equ_posn)*i)))->~G__Tln_equ_posn();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ln_equ_posn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ln_equ_posn*) (soff))->~G__Tln_equ_posn();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_415_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ln_equ_posn* dest = (ln_equ_posn*) G__getstructoffset();
   *dest = *(ln_equ_posn*) libp->para[0].ref;
   const ln_equ_posn& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ln_hrz_posn */
// automatic default constructor
static int G__MCint_416_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ln_hrz_posn *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ln_hrz_posn[n];
     } else {
       p = new((void*) gvp) ln_hrz_posn[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ln_hrz_posn;
     } else {
       p = new((void*) gvp) ln_hrz_posn;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ln_hrz_posn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_416_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ln_hrz_posn* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ln_hrz_posn(*(ln_hrz_posn*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ln_hrz_posn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ln_hrz_posn G__Tln_hrz_posn;
static int G__MCint_416_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ln_hrz_posn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ln_hrz_posn*) (soff+(sizeof(ln_hrz_posn)*i)))->~G__Tln_hrz_posn();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ln_hrz_posn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ln_hrz_posn*) (soff))->~G__Tln_hrz_posn();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_416_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ln_hrz_posn* dest = (ln_hrz_posn*) G__getstructoffset();
   *dest = *(ln_hrz_posn*) libp->para[0].ref;
   const ln_hrz_posn& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ln_lnlat_posn */
// automatic default constructor
static int G__MCint_417_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ln_lnlat_posn *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ln_lnlat_posn[n];
     } else {
       p = new((void*) gvp) ln_lnlat_posn[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ln_lnlat_posn;
     } else {
       p = new((void*) gvp) ln_lnlat_posn;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_417_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ln_lnlat_posn* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ln_lnlat_posn(*(ln_lnlat_posn*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ln_lnlat_posn G__Tln_lnlat_posn;
static int G__MCint_417_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ln_lnlat_posn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ln_lnlat_posn*) (soff+(sizeof(ln_lnlat_posn)*i)))->~G__Tln_lnlat_posn();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ln_lnlat_posn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ln_lnlat_posn*) (soff))->~G__Tln_lnlat_posn();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_417_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ln_lnlat_posn* dest = (ln_lnlat_posn*) G__getstructoffset();
   *dest = *(ln_lnlat_posn*) libp->para[0].ref;
   const ln_lnlat_posn& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ln_rst_time */
// automatic default constructor
static int G__MCint_424_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ln_rst_time *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ln_rst_time[n];
     } else {
       p = new((void*) gvp) ln_rst_time[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ln_rst_time;
     } else {
       p = new((void*) gvp) ln_rst_time;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ln_rst_time));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_424_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ln_rst_time* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ln_rst_time(*(ln_rst_time*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_ln_rst_time));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ln_rst_time G__Tln_rst_time;
static int G__MCint_424_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ln_rst_time*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ln_rst_time*) (soff+(sizeof(ln_rst_time)*i)))->~G__Tln_rst_time();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ln_rst_time*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ln_rst_time*) (soff))->~G__Tln_rst_time();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_424_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ln_rst_time* dest = (ln_rst_time*) G__getstructoffset();
   *dest = *(ln_rst_time*) libp->para[0].ref;
   const ln_rst_time& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Nova */
static int G__MCint_426_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Nova::LnLatPosn& obj = Nova::ORM();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Nova::HrzPosn* pobj;
         Nova::HrzPosn xobj = Nova::GetHrzFromEqu(*(Nova::EquPosn*) libp->para[0].ref, *(Nova::LnLatPosn*) libp->para[1].ref
, (double) G__double(libp->para[2]));
         pobj = new Nova::HrzPosn(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Nova::HrzPosn* pobj;
         Nova::HrzPosn xobj = Nova::GetHrzFromEqu(*(Nova::EquPosn*) libp->para[0].ref, (double) G__double(libp->para[1]));
         pobj = new Nova::HrzPosn(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Nova::EquPosn* pobj;
         Nova::EquPosn xobj = Nova::GetEquFromHrz(*(Nova::HrzPosn*) libp->para[0].ref, *(Nova::LnLatPosn*) libp->para[1].ref
, (double) G__double(libp->para[2]));
         pobj = new Nova::EquPosn(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Nova::EquPosn* pobj;
         Nova::EquPosn xobj = Nova::GetEquFromHrz(*(Nova::HrzPosn*) libp->para[0].ref, (double) G__double(libp->para[1]));
         pobj = new Nova::EquPosn(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         Nova::RstTime* pobj;
         Nova::RstTime xobj = Nova::GetSolarRst((double) G__double(libp->para[0]), *(Nova::LnLatPosn*) libp->para[1].ref
, (double) G__double(libp->para[2]));
         pobj = new Nova::RstTime(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         Nova::RstTime* pobj;
         Nova::RstTime xobj = Nova::GetSolarRst((double) G__double(libp->para[0]), *(Nova::LnLatPosn*) libp->para[1].ref);
         pobj = new Nova::RstTime(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         Nova::RstTime* pobj;
         Nova::RstTime xobj = Nova::GetSolarRst((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
         pobj = new Nova::RstTime(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         Nova::RstTime* pobj;
         Nova::RstTime xobj = Nova::GetSolarRst((double) G__double(libp->para[0]));
         pobj = new Nova::RstTime(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         Nova::RstTime* pobj;
         Nova::RstTime xobj = Nova::GetLunarRst((double) G__double(libp->para[0]), *(Nova::LnLatPosn*) libp->para[1].ref);
         pobj = new Nova::RstTime(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         Nova::RstTime* pobj;
         Nova::RstTime xobj = Nova::GetLunarRst((double) G__double(libp->para[0]));
         pobj = new Nova::RstTime(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Nova::EquPosn* pobj;
         Nova::EquPosn xobj = Nova::GetSolarEquCoords((double) G__double(libp->para[0]));
         pobj = new Nova::EquPosn(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Nova::GetLunarDisk((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Nova::GetLunarSdiam((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Nova::GetLunarPhase((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         Nova::EquPosn* pobj;
         Nova::EquPosn xobj = Nova::GetLunarEquCoords((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
         pobj = new Nova::EquPosn(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         Nova::EquPosn* pobj;
         Nova::EquPosn xobj = Nova::GetLunarEquCoords((double) G__double(libp->para[0]));
         pobj = new Nova::EquPosn(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Nova::GetLunarEarthDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Nova::GetAngularSeparation(*(Nova::EquPosn*) libp->para[0].ref, *(Nova::EquPosn*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_426_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) Nova::GetAngularSeparation(*(Nova::HrzPosn*) libp->para[0].ref, *(Nova::HrzPosn*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}


/* Nova::ZdAzPosn */
static int G__MCint_427_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::ZdAzPosn* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Nova::ZdAzPosn((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) Nova::ZdAzPosn((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Nova::ZdAzPosn((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) Nova::ZdAzPosn((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Nova::ZdAzPosn[n];
       } else {
         p = new((void*) gvp) Nova::ZdAzPosn[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Nova::ZdAzPosn;
       } else {
         p = new((void*) gvp) Nova::ZdAzPosn;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_427_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::ZdAzPosn* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Nova::ZdAzPosn(*(Nova::HrzPosn*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Nova::ZdAzPosn(*(Nova::HrzPosn*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_427_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Nova::ZdAzPosn* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Nova::ZdAzPosn(*(Nova::ZdAzPosn*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Nova::ZdAzPosn G__TNovacLcLZdAzPosn;
static int G__MCint_427_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Nova::ZdAzPosn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Nova::ZdAzPosn*) (soff+(sizeof(Nova::ZdAzPosn)*i)))->~G__TNovacLcLZdAzPosn();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Nova::ZdAzPosn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Nova::ZdAzPosn*) (soff))->~G__TNovacLcLZdAzPosn();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_427_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::ZdAzPosn* dest = (Nova::ZdAzPosn*) G__getstructoffset();
   *dest = *(Nova::ZdAzPosn*) libp->para[0].ref;
   const Nova::ZdAzPosn& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Nova::RaDecPosn */
static int G__MCint_428_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::RaDecPosn* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Nova::RaDecPosn((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) Nova::RaDecPosn((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Nova::RaDecPosn((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) Nova::RaDecPosn((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Nova::RaDecPosn[n];
       } else {
         p = new((void*) gvp) Nova::RaDecPosn[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Nova::RaDecPosn;
       } else {
         p = new((void*) gvp) Nova::RaDecPosn;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_428_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::RaDecPosn* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Nova::RaDecPosn(*(Nova::EquPosn*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Nova::RaDecPosn(*(Nova::EquPosn*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_428_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Nova::RaDecPosn* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Nova::RaDecPosn(*(Nova::RaDecPosn*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Nova::RaDecPosn G__TNovacLcLRaDecPosn;
static int G__MCint_428_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Nova::RaDecPosn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Nova::RaDecPosn*) (soff+(sizeof(Nova::RaDecPosn)*i)))->~G__TNovacLcLRaDecPosn();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Nova::RaDecPosn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Nova::RaDecPosn*) (soff))->~G__TNovacLcLRaDecPosn();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_428_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::RaDecPosn* dest = (Nova::RaDecPosn*) G__getstructoffset();
   *dest = *(Nova::RaDecPosn*) libp->para[0].ref;
   const Nova::RaDecPosn& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Nova::HrzPosn */
static int G__MCint_429_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::HrzPosn* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Nova::HrzPosn[n];
     } else {
       p = new((void*) gvp) Nova::HrzPosn[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Nova::HrzPosn;
     } else {
       p = new((void*) gvp) Nova::HrzPosn;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_429_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::HrzPosn* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Nova::HrzPosn(*(Nova::ZdAzPosn*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Nova::HrzPosn(*(Nova::ZdAzPosn*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_429_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Nova::HrzPosn* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Nova::HrzPosn(*(Nova::HrzPosn*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Nova::HrzPosn G__TNovacLcLHrzPosn;
static int G__MCint_429_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Nova::HrzPosn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Nova::HrzPosn*) (soff+(sizeof(Nova::HrzPosn)*i)))->~G__TNovacLcLHrzPosn();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Nova::HrzPosn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Nova::HrzPosn*) (soff))->~G__TNovacLcLHrzPosn();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_429_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::HrzPosn* dest = (Nova::HrzPosn*) G__getstructoffset();
   *dest = *(Nova::HrzPosn*) libp->para[0].ref;
   const Nova::HrzPosn& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Nova::EquPosn */
static int G__MCint_430_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::EquPosn* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Nova::EquPosn[n];
     } else {
       p = new((void*) gvp) Nova::EquPosn[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Nova::EquPosn;
     } else {
       p = new((void*) gvp) Nova::EquPosn;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_430_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::EquPosn* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Nova::EquPosn(*(Nova::RaDecPosn*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Nova::EquPosn(*(Nova::RaDecPosn*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MCint_430_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Nova::EquPosn* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Nova::EquPosn(*(Nova::EquPosn*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Nova::EquPosn G__TNovacLcLEquPosn;
static int G__MCint_430_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Nova::EquPosn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Nova::EquPosn*) (soff+(sizeof(Nova::EquPosn)*i)))->~G__TNovacLcLEquPosn();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Nova::EquPosn*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Nova::EquPosn*) (soff))->~G__TNovacLcLEquPosn();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MCint_430_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Nova::EquPosn* dest = (Nova::EquPosn*) G__getstructoffset();
   *dest = *(Nova::EquPosn*) libp->para[0].ref;
   const Nova::EquPosn& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* FACT */
static int G__MCint_432_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) FACT::PredictI(*(Nova::SolarObjects*) libp->para[0].ref, *(Nova::EquPosn*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint_432_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) FACT::PredictI(*(double*) G__Doubleref(&libp->para[0]), *(Nova::EquPosn*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__MCint__0_2584(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ln_get_solar_rst_horizon((double) G__double(libp->para[0]), (ln_lnlat_posn*) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (ln_rst_time*) G__int(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2585(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ln_get_solar_rst((double) G__double(libp->para[0]), (ln_lnlat_posn*) G__int(libp->para[1])
, (ln_rst_time*) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2587(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ln_get_solar_equ_coords((double) G__double(libp->para[0]), (ln_equ_posn*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2591(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ln_get_lunar_sdiam((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2592(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ln_get_lunar_rst((double) G__double(libp->para[0]), (ln_lnlat_posn*) G__int(libp->para[1])
, (ln_rst_time*) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2594(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ln_get_lunar_equ_coords_prec((double) G__double(libp->para[0]), (ln_equ_posn*) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2595(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ln_get_lunar_equ_coords((double) G__double(libp->para[0]), (ln_equ_posn*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2597(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ln_get_lunar_phase((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2598(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ln_get_lunar_disk((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2599(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ln_get_lunar_earth_dist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2613(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ln_get_hrz_from_equ((ln_equ_posn*) G__int(libp->para[0]), (ln_lnlat_posn*) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (ln_hrz_posn*) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MCint__0_2624(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ln_get_angular_separation((ln_equ_posn*) G__int(libp->para[0]), (ln_equ_posn*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* FITS */

/* FITS::Compression */

/* izstream */

/* Checksum */

/* fits */

/* ofits */

/* Huffman */

/* zofits */

/* DrsCalibrateTime */

/* factofits */

/* zfits */

/* factfits */

/* PixelMapEntry */

/* PixelMap */

/* BiasMapEntry */

/* BiasMap */

/* Interpolator2D */

/* ln_equ_posn */

/* ln_hrz_posn */

/* ln_lnlat_posn */

/* ln_rst_time */

/* Nova */

/* Nova::ZdAzPosn */

/* Nova::RaDecPosn */

/* Nova::HrzPosn */

/* Nova::EquPosn */

/* FACT */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncMCint {
 public:
  G__Sizep2memfuncMCint(): p(&G__Sizep2memfuncMCint::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncMCint::*p)();
};

size_t G__get_sizep2memfuncMCint()
{
  G__Sizep2memfuncMCint a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */
static long G__2vbo_izstream_basic_ioslEcharcOchar_traitslEchargRsPgR_2(long pobject) {
  izstream *G__Lderived=(izstream*)pobject;
  basic_ios<char,char_traits<char> > *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_izstream_ios_base_3(long pobject) {
  izstream *G__Lderived=(izstream*)pobject;
  ios_base *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_fits_basic_ioslEcharcOchar_traitslEchargRsPgR_3(long pobject) {
  fits *G__Lderived=(fits*)pobject;
  basic_ios<char,char_traits<char> > *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_fits_ios_base_4(long pobject) {
  fits *G__Lderived=(fits*)pobject;
  ios_base *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ofits_basic_ioslEcharcOchar_traitslEchargRsPgR_1(long pobject) {
  ofits *G__Lderived=(ofits*)pobject;
  basic_ios<char,char_traits<char> > *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ofits_ios_base_2(long pobject) {
  ofits *G__Lderived=(ofits*)pobject;
  ios_base *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_zofits_basic_ioslEcharcOchar_traitslEchargRsPgR_2(long pobject) {
  zofits *G__Lderived=(zofits*)pobject;
  basic_ios<char,char_traits<char> > *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_zofits_ios_base_3(long pobject) {
  zofits *G__Lderived=(zofits*)pobject;
  ios_base *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_factofits_basic_ioslEcharcOchar_traitslEchargRsPgR_3(long pobject) {
  factofits *G__Lderived=(factofits*)pobject;
  basic_ios<char,char_traits<char> > *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_factofits_ios_base_4(long pobject) {
  factofits *G__Lderived=(factofits*)pobject;
  ios_base *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_zfits_basic_ioslEcharcOchar_traitslEchargRsPgR_4(long pobject) {
  zfits *G__Lderived=(zfits*)pobject;
  basic_ios<char,char_traits<char> > *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_zfits_ios_base_5(long pobject) {
  zfits *G__Lderived=(zfits*)pobject;
  ios_base *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_factfits_basic_ioslEcharcOchar_traitslEchargRsPgR_5(long pobject) {
  factfits *G__Lderived=(factfits*)pobject;
  basic_ios<char,char_traits<char> > *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_factfits_ios_base_6(long pobject) {
  factfits *G__Lderived=(factfits*)pobject;
  ios_base *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}


/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceMCint() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_izstream))) {
     izstream *G__Lderived;
     G__Lderived=(izstream*)0x1000;
     {
       basic_streambuf<char,char_traits<char> > *G__Lpbase=(basic_streambuf<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_izstream),G__get_linked_tagnum(&G__MCintLN_basic_streambuflEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       basic_istream<char,char_traits<char> > *G__Lpbase=(basic_istream<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_izstream),G__get_linked_tagnum(&G__MCintLN_basic_istreamlEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_izstream),G__get_linked_tagnum(&G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR),(long)G__2vbo_izstream_basic_ioslEcharcOchar_traitslEchargRsPgR_2,1,2);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_izstream),G__get_linked_tagnum(&G__MCintLN_ios_base),(long)G__2vbo_izstream_ios_base_3,1,6);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_fits))) {
     fits *G__Lderived;
     G__Lderived=(fits*)0x1000;
     {
       izstream *G__Lpbase=(izstream*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_fits),G__get_linked_tagnum(&G__MCintLN_izstream),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       basic_streambuf<char,char_traits<char> > *G__Lpbase=(basic_streambuf<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_fits),G__get_linked_tagnum(&G__MCintLN_basic_streambuflEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       basic_istream<char,char_traits<char> > *G__Lpbase=(basic_istream<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_fits),G__get_linked_tagnum(&G__MCintLN_basic_istreamlEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_fits),G__get_linked_tagnum(&G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR),(long)G__2vbo_fits_basic_ioslEcharcOchar_traitslEchargRsPgR_3,1,2);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_fits),G__get_linked_tagnum(&G__MCintLN_ios_base),(long)G__2vbo_fits_ios_base_4,1,6);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_ofits))) {
     ofits *G__Lderived;
     G__Lderived=(ofits*)0x1000;
     {
       basic_ostream<char,char_traits<char> > *G__Lpbase=(basic_ostream<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_ofits),G__get_linked_tagnum(&G__MCintLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_ofits),G__get_linked_tagnum(&G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR),(long)G__2vbo_ofits_basic_ioslEcharcOchar_traitslEchargRsPgR_1,1,2);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_ofits),G__get_linked_tagnum(&G__MCintLN_ios_base),(long)G__2vbo_ofits_ios_base_2,1,6);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_zofits))) {
     zofits *G__Lderived;
     G__Lderived=(zofits*)0x1000;
     {
       ofits *G__Lpbase=(ofits*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zofits),G__get_linked_tagnum(&G__MCintLN_ofits),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       basic_ostream<char,char_traits<char> > *G__Lpbase=(basic_ostream<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zofits),G__get_linked_tagnum(&G__MCintLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zofits),G__get_linked_tagnum(&G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR),(long)G__2vbo_zofits_basic_ioslEcharcOchar_traitslEchargRsPgR_2,1,2);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zofits),G__get_linked_tagnum(&G__MCintLN_ios_base),(long)G__2vbo_zofits_ios_base_3,1,6);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_factofits))) {
     factofits *G__Lderived;
     G__Lderived=(factofits*)0x1000;
     {
       zofits *G__Lpbase=(zofits*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factofits),G__get_linked_tagnum(&G__MCintLN_zofits),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ofits *G__Lpbase=(ofits*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factofits),G__get_linked_tagnum(&G__MCintLN_ofits),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       basic_ostream<char,char_traits<char> > *G__Lpbase=(basic_ostream<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factofits),G__get_linked_tagnum(&G__MCintLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factofits),G__get_linked_tagnum(&G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR),(long)G__2vbo_factofits_basic_ioslEcharcOchar_traitslEchargRsPgR_3,1,2);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factofits),G__get_linked_tagnum(&G__MCintLN_ios_base),(long)G__2vbo_factofits_ios_base_4,1,6);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_zfits))) {
     zfits *G__Lderived;
     G__Lderived=(zfits*)0x1000;
     {
       fits *G__Lpbase=(fits*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zfits),G__get_linked_tagnum(&G__MCintLN_fits),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       izstream *G__Lpbase=(izstream*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zfits),G__get_linked_tagnum(&G__MCintLN_izstream),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       basic_streambuf<char,char_traits<char> > *G__Lpbase=(basic_streambuf<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zfits),G__get_linked_tagnum(&G__MCintLN_basic_streambuflEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       basic_istream<char,char_traits<char> > *G__Lpbase=(basic_istream<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zfits),G__get_linked_tagnum(&G__MCintLN_basic_istreamlEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zfits),G__get_linked_tagnum(&G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR),(long)G__2vbo_zfits_basic_ioslEcharcOchar_traitslEchargRsPgR_4,1,2);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_zfits),G__get_linked_tagnum(&G__MCintLN_ios_base),(long)G__2vbo_zfits_ios_base_5,1,6);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_factfits))) {
     factfits *G__Lderived;
     G__Lderived=(factfits*)0x1000;
     {
       zfits *G__Lpbase=(zfits*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factfits),G__get_linked_tagnum(&G__MCintLN_zfits),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       fits *G__Lpbase=(fits*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factfits),G__get_linked_tagnum(&G__MCintLN_fits),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       izstream *G__Lpbase=(izstream*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factfits),G__get_linked_tagnum(&G__MCintLN_izstream),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       basic_streambuf<char,char_traits<char> > *G__Lpbase=(basic_streambuf<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factfits),G__get_linked_tagnum(&G__MCintLN_basic_streambuflEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       basic_istream<char,char_traits<char> > *G__Lpbase=(basic_istream<char,char_traits<char> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factfits),G__get_linked_tagnum(&G__MCintLN_basic_istreamlEcharcOchar_traitslEchargRsPgR),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factfits),G__get_linked_tagnum(&G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR),(long)G__2vbo_factfits_basic_ioslEcharcOchar_traitslEchargRsPgR_5,1,2);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_factfits),G__get_linked_tagnum(&G__MCintLN_ios_base),(long)G__2vbo_factfits_ios_base_6,1,6);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_PixelMap))) {
     PixelMap *G__Lderived;
     G__Lderived=(PixelMap*)0x1000;
     {
       vector<PixelMapEntry,allocator<PixelMapEntry> > *G__Lpbase=(vector<PixelMapEntry,allocator<PixelMapEntry> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_PixelMap),G__get_linked_tagnum(&G__MCintLN_vectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgR),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_BiasMap))) {
     BiasMap *G__Lderived;
     G__Lderived=(BiasMap*)0x1000;
     {
       vector<BiasMapEntry,allocator<BiasMapEntry> > *G__Lpbase=(vector<BiasMapEntry,allocator<BiasMapEntry> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_BiasMap),G__get_linked_tagnum(&G__MCintLN_vectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgR),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn))) {
     Nova::HrzPosn *G__Lderived;
     G__Lderived=(Nova::HrzPosn*)0x1000;
     {
       ln_hrz_posn *G__Lpbase=(ln_hrz_posn*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn),G__get_linked_tagnum(&G__MCintLN_ln_hrz_posn),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn))) {
     Nova::EquPosn *G__Lderived;
     G__Lderived=(Nova::EquPosn*)0x1000;
     {
       ln_equ_posn *G__Lpbase=(ln_equ_posn*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn),G__get_linked_tagnum(&G__MCintLN_ln_equ_posn),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableMCint() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__MCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("int16_t",115,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("int32_t",105,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("int64_t",108,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("uint8_t",98,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("uint16_t",114,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("uint32_t",104,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("uint64_t",107,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<uint16_t>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<unsigned short>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<UInt_t>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<unsigned int>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TString>",117,G__get_linked_tagnum(&G__MCintLN_vectorlETStringcOallocatorlETStringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlETStringcOallocatorlETStringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlETStringcOallocatorlETStringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<char>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEcharcOallocatorlEchargRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEcharcOallocatorlEchargRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<std::string,Entry>",117,G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLEntrycOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLEntrygRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,Entry>",117,G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLEntrycOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLEntrygRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,fits::Entry>",117,G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLEntrycOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLEntrygRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,fits::Entry,less<string> >",117,G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLEntrycOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLEntrygRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<std::string,Column>",117,G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLTablecLcLColumncOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLTablecLcLColumngRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,Column>",117,G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLTablecLcLColumncOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLTablecLcLColumngRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,fits::Table::Column>",117,G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLTablecLcLColumncOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLTablecLcLColumngRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,fits::Table::Column,less<string> >",117,G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLTablecLcLColumncOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLTablecLcLColumngRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Column>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<fits::Table::Column>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::string>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<string>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<string>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<void*,Table::Column>",117,G__get_linked_tagnum(&G__MCintLN_pairlEvoidmUcOfitscLcLTablecLcLColumngR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Address",117,G__get_linked_tagnum(&G__MCintLN_pairlEvoidmUcOfitscLcLTablecLcLColumngR),0,G__get_linked_tagnum(&G__MCintLN_fits));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Address>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<void*,fits::Table::Column> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Addresses",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR),0,G__get_linked_tagnum(&G__MCintLN_fits));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("unordered_map<std::string,void*>",117,G__get_linked_tagnum(&G__MCintLN_unordered_maplEstringcOvoidmUgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("unordered_map<string,void*>",117,G__get_linked_tagnum(&G__MCintLN_unordered_maplEstringcOvoidmUgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Pointers",117,G__get_linked_tagnum(&G__MCintLN_unordered_maplEstringcOvoidmUgR),0,G__get_linked_tagnum(&G__MCintLN_fits));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::vector<char> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<char> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<char,allocator<char> > >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Key>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ofits::Key>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Table::Column>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ofits::Table::Column>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<std::string,int>",117,G__get_linked_tagnum(&G__MCintLN_pairlEstringcOintgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<string,int>",117,G__get_linked_tagnum(&G__MCintLN_pairlEstringcOintgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("forward_list<std::shared_ptr<char> >",117,G__get_linked_tagnum(&G__MCintLN_forward_listlEshared_ptrlEchargRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("forward_list<shared_ptr<char> >",117,G__get_linked_tagnum(&G__MCintLN_forward_listlEshared_ptrlEchargRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<CatalogEntry>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<zofits::CatalogEntry>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("CatalogRow",117,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR),0,G__get_linked_tagnum(&G__MCintLN_zofits));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("list<CatalogRow>",117,G__get_linked_tagnum(&G__MCintLN_listlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcOallocatorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("list<vector<zofits::CatalogEntry,allocator<zofits::CatalogEntry> > >",117,G__get_linked_tagnum(&G__MCintLN_listlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcOallocatorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("CatalogType",117,G__get_linked_tagnum(&G__MCintLN_listlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcOallocatorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MCintLN_zofits));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("list<zofits::CompressionTarget>",117,G__get_linked_tagnum(&G__MCintLN_listlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Queue<CompressionTarget>",117,G__get_linked_tagnum(&G__MCintLN_QueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Queue<zofits::CompressionTarget>",117,G__get_linked_tagnum(&G__MCintLN_QueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Queue<CompressionTarget> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget,allocator<zofits::CompressionTarget> > > >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("QueueMin<WriteTarget>",117,G__get_linked_tagnum(&G__MCintLN_zofitscLcLQueueMinlEzofitscLcLWriteTargetgR),0,G__get_linked_tagnum(&G__MCintLN_zofits));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("list<zofits::WriteTarget>",117,G__get_linked_tagnum(&G__MCintLN_listlEzofitscLcLWriteTargetcOallocatorlEzofitscLcLWriteTargetgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Queue<WriteTarget,QueueMin<WriteTarget> >",117,G__get_linked_tagnum(&G__MCintLN_QueuelEzofitscLcLWriteTargetcOzofitscLcLQueueMinlEzofitscLcLWriteTargetgRsPgR),0,G__get_linked_tagnum(&G__MCintLN_zofits));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Queue<zofits::WriteTarget>",117,G__get_linked_tagnum(&G__MCintLN_QueuelEzofitscLcLWriteTargetcOzofitscLcLQueueMinlEzofitscLcLWriteTargetgRsPgR),0,G__get_linked_tagnum(&G__MCintLN_zofits));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<CompressedColumn>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<zofits::CompressedColumn>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int64_t>",117,G__get_linked_tagnum(&G__MCintLN_vectorlElongcOallocatorlElonggRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlElongcOallocatorlElonggRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlElongcOallocatorlElonggRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlElongcOallocatorlElonggRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlElongcOallocatorlElonggRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<long>",117,G__get_linked_tagnum(&G__MCintLN_vectorlElongcOallocatorlElonggRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Step>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<DrsCalibrate::Step>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<double>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<std::vector<double>,std::vector<double> >",117,G__get_linked_tagnum(&G__MCintLN_pairlEvectorlEdoublecOallocatorlEdoublegRsPgRcOvectorlEdoublecOallocatorlEdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<vector<double>,std::vector<double> >",117,G__get_linked_tagnum(&G__MCintLN_pairlEvectorlEdoublecOallocatorlEdoublegRsPgRcOvectorlEdoublecOallocatorlEdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::pair<double,double> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<double,double> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<double,double> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int32_t>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<float>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEfloatcOallocatorlEfloatgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEfloatcOallocatorlEfloatgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int16_t>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEshortcOallocatorlEshortgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEshortcOallocatorlEshortgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<short>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<int64_t,int64_t>",117,G__get_linked_tagnum(&G__MCintLN_pairlElongcOlonggR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::pair<int64_t,int64_t> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<int64_t,int64_t> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<long,long> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::vector<std::pair<int64_t,int64_t> > >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<pair<int64_t,int64_t> > >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<pair<long,long>,allocator<pair<long,long> > > >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<size_t>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<unsigned long>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::vector<size_t> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<size_t> >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<unsigned long,allocator<unsigned long> > >",117,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<PixelMapEntry>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<BiasMapEntry>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<point>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Interpolator2D::point>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<circle>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Interpolator2D::circle>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<weight>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Interpolator2D::weight>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Interpolator2D::vec>",117,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("LnLatPosn",117,G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn),0,G__get_linked_tagnum(&G__MCintLN_Nova));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("RstTime",117,G__get_linked_tagnum(&G__MCintLN_ln_rst_time),0,G__get_linked_tagnum(&G__MCintLN_Nova));
   G__setnewtype(-1,"Note that times are in JD not Mjd",0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* FITS */
static void G__setup_memvarFITS(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_FITS));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__MCintLN_FITScLcLCompressionProcess_t),-1,-2,1,G__FastAllocString(2048).Format("kFactRaw=%lldLL",(long long)FITS::kFactRaw).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__MCintLN_FITScLcLCompressionProcess_t),-1,-2,1,G__FastAllocString(2048).Format("kFactSmoothing=%lldLL",(long long)FITS::kFactSmoothing).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__MCintLN_FITScLcLCompressionProcess_t),-1,-2,1,G__FastAllocString(2048).Format("kFactHuffman16=%lldLL",(long long)FITS::kFactHuffman16).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__MCintLN_FITScLcLRowOrdering_t),-1,-2,1,G__FastAllocString(2048).Format("kOrderByCol=%lldLL",(long long)FITS::kOrderByCol).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__MCintLN_FITScLcLRowOrdering_t),-1,-2,1,G__FastAllocString(2048).Format("kOrderByRow=%lldLL",(long long)FITS::kOrderByRow).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* FITS::Compression */
static void G__setup_memvarFITScLcLCompression(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression));
   { FITS::Compression *p; p=(FITS::Compression*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->sequence)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR),G__defined_typename("vector<uint16_t>"),-1,1,"sequence=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->header)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MCintLN_FITScLcLBlockHeader),-1,-1,1,"header=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* izstream */
static void G__setup_memvarizstream(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_izstream));
   { izstream *p; p=(izstream*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,-1,-1,-2,4,"fgBufferSize=4194304LL",0,(char*)NULL);
   G__memvar_setup((void*)0,89,0,0,-1,G__defined_typename("gzFile"),-1,4,"fFile=",0,"file handle for compressed file");
   G__memvar_setup((void*)0,67,0,0,-1,-1,-1,4,"fBuffer=",0,"data buffer");
   }
   G__tag_memvar_reset();
}


   /* Checksum */
static void G__setup_memvarChecksum(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_Checksum));
   { Checksum *p; p=(Checksum*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->buffer)-(long)(p)),107,0,0,-1,G__defined_typename("uint64_t"),-1,1,"buffer=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* fits */
static void G__setup_memvarfits(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_fits));
   { fits *p; p=(fits*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__MCintLN_fitscLcLCompression_t),-1,-2,1,G__FastAllocString(2048).Format("kCompUnknown=%lldLL",(long long)fits::kCompUnknown).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__MCintLN_fitscLcLCompression_t),-1,-2,1,G__FastAllocString(2048).Format("kCompFACT=%lldLL",(long long)fits::kCompFACT).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__MCintLN_fitscLcLfitsstate),-1,-2,1,G__FastAllocString(2048).Format("throwbit=%lldLL",(long long)fits::throwbit).data(),0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_basic_ofstreamlEcharcOchar_traitslEchargRsPgR),G__defined_typename("ofstream"),-1,2,"fCopy=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR),G__defined_typename("vector<std::string>"),-1,2,"fListOfTables=",0,"List of skipped tables. Last table is open table");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_fitscLcLTable),-1,-1,2,"fTable=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR),G__defined_typename("Addresses"),-1,2,"fAddresses=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_unordered_maplEstringcOvoidmUgR),G__defined_typename("Pointers"),-1,2,"fPointers=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<char> >"),-1,2,"fGarbage=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),G__defined_typename("vector<char>"),-1,2,"fBufferRow=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),G__defined_typename("vector<char>"),-1,2,"fBufferDat=",0,(char*)NULL);
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,2,"fRow=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_Checksum),-1,-1,2,"fChkHeader=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_Checksum),-1,-1,2,"fChkData=",0,(char*)NULL);
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ofits */
static void G__setup_memvarofits(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_ofits));
   { ofits *p; p=(ofits*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_basic_filebuflEcharcOchar_traitslEchargRsPgR),G__defined_typename("filebuf"),-1,2,"fFilebuf=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgR),G__defined_typename("vector<Key>"),-1,4,"fKeys=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_ofitscLcLTable),-1,-1,2,"fTable=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),G__defined_typename("vector<char>"),-1,2,"fOutputBuffer=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_Checksum),-1,-1,2,"fDataSum=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_Checksum),-1,-1,2,"fHeaderSum=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fCommentTrimming=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fManualExtName=",0,(char*)NULL);
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Huffman */
static void G__setup_memvarHuffman(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_Huffman));
   {
   }
   G__tag_memvar_reset();
}


   /* zofits */
static void G__setup_memvarzofits(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_zofits));
   { zofits *p; p=(zofits*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_MemoryManager),-1,-1,2,"fMemPool=",0,"/< Actual memory manager, providing memory for the compression buffers");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("int32_t"),-1,2,"fNumQueues=",0,"/< Current number of threads that will be used by this object");
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("uint64_t"),-1,2,"fMaxUsableMem=",0,"/< Maximum number of bytes that can be allocated by the memory manager");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("int32_t"),-1,2,"fLatestWrittenTile=",0,"/< Index of the last tile written to disk (for correct ordering while using several threads)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgR),G__defined_typename("vector<Queue<CompressionTarget> >"),-1,2,"fCompressionQueues=",0,"/< Processing queues (=threads)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_QueuelEzofitscLcLWriteTargetcOzofitscLcLQueueMinlEzofitscLcLWriteTargetgRsPgR),G__defined_typename("Queue<WriteTarget,QueueMin<WriteTarget> >"),-1,2,"fWriteToDiskQueue=",0,"/< Writing queue (=thread)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_listlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcOallocatorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRsPgRsPgR),G__defined_typename("CatalogType"),-1,2,"fCatalog=",0,"/< Catalog for this file");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("uint32_t"),-1,2,"fCatalogSize=",0,"/< Actual catalog size (.size() is slow on large lists)");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("uint32_t"),-1,2,"fNumTiles=",0,"/< Number of pre-reserved tiles");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("uint32_t"),-1,2,"fNumRowsPerTile=",0,"/< Number of rows per tile");
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,2,"fCatalogOffset=",0,"/< Offset of the catalog from the beginning of the file");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_Checksum),-1,-1,2,"fCatalogSum=",0,"/< Checksum of the catalog");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_Checksum),-1,-1,2,"fRawSum=",0,"/< Raw sum (specific to FACT)");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("int32_t"),-1,2,"fCheckOffset=",0,"/< offset to the data pointer to calculate the checksum");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgR),G__defined_typename("vector<CompressedColumn>"),-1,2,"fRealColumns=",0,"/< Vector hosting the columns of the file");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("uint32_t"),-1,2,"fRealRowWidth=",0,"/< Width in bytes of one uncompressed row");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_shared_ptrlEchargR),-1,-1,2,"fSmartBuffer=",0,"/< Smart pointer to the buffer where the incoming rows are written");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),G__defined_typename("vector<char>"),-1,2,"fRawSumBuffer=",0,"/< buffer used for checksuming the incoming data, before compression");
   G__memvar_setup((void*)0,89,0,0,-1,G__defined_typename("exception_ptr"),-1,2,"fThreadsException=",0,"/< exception pointer to store exceptions coming from the threads");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fErrno=",0,"/< propagate errno to main thread");
   }
   G__tag_memvar_reset();
}


   /* DrsCalibrateTime */
static void G__setup_memvarDrsCalibrateTime(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime));
   { DrsCalibrateTime *p; p=(DrsCalibrateTime*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fNumEntries)-(long)(p)),108,0,0,-1,G__defined_typename("int64_t"),-1,1,"fNumEntries=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fNumSamples)-(long)(p)),107,0,0,-1,G__defined_typename("size_t"),-1,1,"fNumSamples=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fNumChannels)-(long)(p)),107,0,0,-1,G__defined_typename("size_t"),-1,1,"fNumChannels=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fStat)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR),G__defined_typename("vector<std::pair<double,double> >"),-1,1,"fStat=",0,(char*)NULL);
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* factofits */
static void G__setup_memvarfactofits(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_factofits));
   { factofits *p; p=(factofits*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR),G__defined_typename("vector<int16_t>"),-1,4,"fOffsetCalibration=",0,"/< The calibration itself");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("int32_t"),-1,4,"fStartCellsOffset=",0,"/< Offset in bytes for the startcell data");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("int32_t"),-1,4,"fDataOffset=",0,"/< Offset in bytes for the data");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("int32_t"),-1,4,"fNumSlices=",0,"/< Number of samples per pixel per event");
   }
   G__tag_memvar_reset();
}


   /* zfits */
static void G__setup_memvarzfits(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_zfits));
   { zfits *p; p=(zfits*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fCatalogInitialized=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),G__defined_typename("vector<char>"),-1,4,"fBuffer=",0,"/<store the uncompressed rows");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),G__defined_typename("vector<char>"),-1,4,"fTransposedBuffer=",0,"/<intermediate buffer to transpose the rows");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),G__defined_typename("vector<char>"),-1,4,"fCompressedBuffer=",0,"/<compressed rows");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR),G__defined_typename("vector<char>"),-1,4,"fColumnOrdering=",0,"/< ordering of the column's rows. Can change from tile to tile.");
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"fNumTiles=",0,"/< Total number of tiles");
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"fNumRowsPerTile=",0,"/< Number of rows per compressed tile");
   G__memvar_setup((void*)0,108,0,0,-1,G__defined_typename("int64_t"),-1,4,"fCurrentRow=",0,"/< current row in memory signed because we need -1");
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"fShrinkFactor=",0,"/< shrink factor");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("streamoff"),-1,4,"fHeapOff=",0,"/< offset from the beginning of the file of the binary data");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("streamoff"),-1,4,"fHeapFromDataStart=",0,"/< offset from the beginning of the data table");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<std::pair<int64_t,int64_t> > >"),-1,4,"fCatalog=",0,"/< Catalog, i.e. the main table that points to the compressed data.");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgR),G__defined_typename("vector<size_t>"),-1,4,"fTileSize=",0,"/< size in bytes of each compressed tile");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR),G__defined_typename("vector<std::vector<size_t> >"),-1,4,"fTileOffsets=",0,"/< offset from start of tile of a given compressed column");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_Checksum),-1,-1,4,"fRawsum=",0,"/< Checksum of the uncompressed, raw data");
   }
   G__tag_memvar_reset();
}


   /* factfits */
static void G__setup_memvarfactfits(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_factfits));
   { factfits *p; p=(factfits*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR),G__defined_typename("vector<int16_t>"),-1,4,"fOffsetCalibration=",0,"/< integer values of the drs calibration used for compression");
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"fOffsetStartCellData=",0,(char*)NULL);
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"fOffsetData=",0,(char*)NULL);
   G__memvar_setup((void*)0,114,0,0,-1,G__defined_typename("uint16_t"),-1,4,"fNumRoi=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* PixelMapEntry */
static void G__setup_memvarPixelMapEntry(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_PixelMapEntry));
   { PixelMapEntry *p; p=(PixelMapEntry*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->index)-(long)(p)),105,0,0,-1,-1,-1,1,"index=",0,"/ Software index");
   G__memvar_setup((void*)((long)(&p->cbpx)-(long)(p)),105,0,0,-1,-1,-1,1,"cbpx=",0,"/ Hardware index as CBPX");
   G__memvar_setup((void*)((long)(&p->gapd)-(long)(p)),105,0,0,-1,-1,-1,1,"gapd=",0,"/ gAPD index");
   G__memvar_setup((void*)((long)(&p->hv_board)-(long)(p)),105,0,0,-1,-1,-1,1,"hv_board=",0,"/ Bias suppply board");
   G__memvar_setup((void*)((long)(&p->hv_channel)-(long)(p)),105,0,0,-1,-1,-1,1,"hv_channel=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* PixelMap */
static void G__setup_memvarPixelMap(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_PixelMap));
   { PixelMap *p; p=(PixelMap*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* BiasMapEntry */
static void G__setup_memvarBiasMapEntry(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_BiasMapEntry));
   { BiasMapEntry *p; p=(BiasMapEntry*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->hv_board)-(long)(p)),105,0,0,-1,-1,-1,1,"hv_board=",0,"/ Bias suppply board");
   G__memvar_setup((void*)((long)(&p->hv_channel)-(long)(p)),105,0,0,-1,-1,-1,1,"hv_channel=",0,"/ Bias supply channel");
   G__memvar_setup((void*)((long)(&p->Vnom)-(long)(p)),102,0,0,-1,-1,-1,1,"Vnom=",0,"/ Channel bias voltage nominal");
   G__memvar_setup((void*)((long)(&p->Voff)-(long)(p)),102,0,0,-1,-1,-1,1,"Voff=",0,"/ Channel bias voltage offset [V]");
   G__memvar_setup((void*)((long)(&p->Vslope)-(long)(p)),102,0,0,-1,-1,-1,1,"Vslope=",0,"/ Channel bias voltage slope  [Ohm]");
   }
   G__tag_memvar_reset();
}


   /* BiasMap */
static void G__setup_memvarBiasMap(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_BiasMap));
   { BiasMap *p; p=(BiasMap*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Interpolator2D */
static void G__setup_memvarInterpolator2D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_Interpolator2D));
   { Interpolator2D *p; p=(Interpolator2D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR),G__defined_typename("vector<point>"),-1,4,"inputGrid=",0,"/ positions of the data points (e.g. sensors)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR),G__defined_typename("vector<point>"),-1,4,"outputGrid=",0,"/ positions at which inter-/extrapolated values should be provided");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgR),G__defined_typename("vector<circle>"),-1,4,"circles=",0,"/ the calculated circles/triangles");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR),G__defined_typename("vector<weight>"),-1,4,"weights=",0,"/ the weights used for the interpolation");
   }
   G__tag_memvar_reset();
}


   /* ln_equ_posn */
static void G__setup_memvarln_equ_posn(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_ln_equ_posn));
   { ln_equ_posn *p; p=(ln_equ_posn*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ra)-(long)(p)),100,0,0,-1,-1,-1,1,"ra=",0,"!< RA. Object right ascension in degrees.*/");
   G__memvar_setup((void*)((long)(&p->dec)-(long)(p)),100,0,0,-1,-1,-1,1,"dec=",0,"!< DEC. Object declination */");
   }
   G__tag_memvar_reset();
}


   /* ln_hrz_posn */
static void G__setup_memvarln_hrz_posn(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_ln_hrz_posn));
   { ln_hrz_posn *p; p=(ln_hrz_posn*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->az)-(long)(p)),100,0,0,-1,-1,-1,1,"az=",0,"!< AZ. Object azimuth. <p>");
   G__memvar_setup((void*)((long)(&p->alt)-(long)(p)),100,0,0,-1,-1,-1,1,"alt=",0,"!< ALT. Object altitude. <p> 0 deg = horizon, 90 deg = zenit, -90 deg = nadir */");
   }
   G__tag_memvar_reset();
}


   /* ln_lnlat_posn */
static void G__setup_memvarln_lnlat_posn(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn));
   { ln_lnlat_posn *p; p=(ln_lnlat_posn*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->lng)-(long)(p)),100,0,0,-1,-1,-1,1,"lng=",0,"!< longitude. Object longitude. */");
   G__memvar_setup((void*)((long)(&p->lat)-(long)(p)),100,0,0,-1,-1,-1,1,"lat=",0,"!< latitude. Object latitude */");
   }
   G__tag_memvar_reset();
}


   /* ln_rst_time */
static void G__setup_memvarln_rst_time(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_ln_rst_time));
   { ln_rst_time *p; p=(ln_rst_time*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->rise)-(long)(p)),100,0,0,-1,-1,-1,1,"rise=",0,"!< Rise time in JD */");
   G__memvar_setup((void*)((long)(&p->set)-(long)(p)),100,0,0,-1,-1,-1,1,"set=",0,"!< Set time in JD */");
   G__memvar_setup((void*)((long)(&p->transit)-(long)(p)),100,0,0,-1,-1,-1,1,"transit=",0,"!< Transit time in JD */");
   }
   G__tag_memvar_reset();
}


   /* Nova */
static void G__setup_memvarNova(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_Nova));
   {
   }
   G__tag_memvar_reset();
}


   /* Nova::ZdAzPosn */
static void G__setup_memvarNovacLcLZdAzPosn(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn));
   { Nova::ZdAzPosn *p; p=(Nova::ZdAzPosn*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->zd)-(long)(p)),100,0,0,-1,-1,-1,1,"zd=",0,"[deg]");
   G__memvar_setup((void*)((long)(&p->az)-(long)(p)),100,0,0,-1,-1,-1,1,"az=",0,"[deg]");
   }
   G__tag_memvar_reset();
}


   /* Nova::RaDecPosn */
static void G__setup_memvarNovacLcLRaDecPosn(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn));
   { Nova::RaDecPosn *p; p=(Nova::RaDecPosn*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ra)-(long)(p)),100,0,0,-1,-1,-1,1,"ra=",0,"[h]");
   G__memvar_setup((void*)((long)(&p->dec)-(long)(p)),100,0,0,-1,-1,-1,1,"dec=",0,"[deg]");
   }
   G__tag_memvar_reset();
}


   /* Nova::HrzPosn */
static void G__setup_memvarNovacLcLHrzPosn(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn));
   { Nova::HrzPosn *p; p=(Nova::HrzPosn*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Nova::EquPosn */
static void G__setup_memvarNovacLcLEquPosn(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn));
   { Nova::EquPosn *p; p=(Nova::EquPosn*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* FACT */
static void G__setup_memvarFACT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MCintLN_FACT));
   {
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarMCint() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncFITS(void) {
   /* FITS */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_FITS));
   G__memfunc_setup("IsReservedKeyWord",1729,G__MCint_107_0_1, 103, -1, -1, 0, 1, 3, 1, 0, "u 'string' - 11 - key", (char*)NULL, (void*) G__func2void( (bool (*)(const string&))(&FITS::IsReservedKeyWord) ), 0);
   G__memfunc_setup("CommentFromType",1545,G__MCint_107_0_2, 117, G__get_linked_tagnum(&G__MCintLN_string), -1, 0, 1, 3, 1, 0, "c - - 0 - type", (char*)NULL, (void*) G__func2void( (string (*)(char))(&FITS::CommentFromType) ), 0);
   G__memfunc_setup("SizeFromType",1233,G__MCint_107_0_3, 104, -1, G__defined_typename("uint32_t"), 0, 1, 3, 1, 0, "c - - 0 - type", (char*)NULL, (void*) G__func2void( (uint32_t (*)(char))(&FITS::SizeFromType) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFITScLcLCompression(void) {
   /* FITS::Compression */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression));
   G__memfunc_setup("Compression",1170,G__MCint_112_0_1, 105, G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression), -1, 0, 2, 1, 1, 0, 
"u 'vector<unsigned short,allocator<unsigned short> >' 'vector<uint16_t>' 11 - seq i 'FITS::RowOrdering_t' - 11 'kOrderByCol' order", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Compression",1170,G__MCint_112_0_2, 105, G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression), -1, 0, 2, 1, 1, 0, 
"i 'FITS::CompressionProcess_t' - 11 'kFactRaw' compression i 'FITS::RowOrdering_t' - 11 'kOrderByCol' order", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Compression",1170,G__MCint_112_0_3, 105, G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression), -1, 0, 1, 1, 1, 0, "i - - 11 - compression", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getOrdering",1146,G__MCint_112_0_4, 105, G__get_linked_tagnum(&G__MCintLN_FITScLcLRowOrdering_t), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getSizeOnDisk",1315,G__MCint_112_0_5, 104, -1, G__defined_typename("uint32_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getProc",724,G__MCint_112_0_6, 105, G__get_linked_tagnum(&G__MCintLN_FITScLcLCompressionProcess_t), -1, 0, 1, 1, 1, 8, "h - 'uint32_t' 0 - i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getNumProcs",1143,G__MCint_112_0_7, 114, -1, G__defined_typename("uint16_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetBlockSize",1202,G__MCint_112_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'uint64_t' 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Memcpy",619,G__MCint_112_0_9, 121, -1, -1, 0, 1, 1, 1, 8, "C - - 0 - dest", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Compression", 1170, G__MCint_112_0_10, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression), -1, 0, 1, 1, 1, 0, "u 'FITS::Compression' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Compression", 1296, G__MCint_112_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_112_0_12, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_FITScLcLCompression), -1, 1, 1, 1, 1, 0, "u 'FITS::Compression' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncizstream(void) {
   /* izstream */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_izstream));
   G__memfunc_setup("underflow",982,(G__InterfaceMethod) NULL, 105, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("izstream",879,G__MCint_210_0_2, 105, G__get_linked_tagnum(&G__MCintLN_izstream), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("izstream",879,G__MCint_210_0_3, 105, G__get_linked_tagnum(&G__MCintLN_izstream), -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("is_open",749,G__MCint_210_0_4, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("open",434,G__MCint_210_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("close",534,G__MCint_210_0_6, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("seekoff",739,G__MCint_210_0_7, 110, -1, G__defined_typename("basic_streambuf<char,char_traits<char> >::pos_type"), 0, 3, 1, 1, 0, 
"n - 'basic_streambuf<char,char_traits<char> >::off_type' 0 - offset i - 'ios_base::seekdir' 0 - dir "
"i - 'ios_base::openmode' 0 'std::ios_base::in' -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("seekpos",762,G__MCint_210_0_8, 110, -1, G__defined_typename("basic_streambuf<char,char_traits<char> >::pos_type"), 0, 2, 1, 1, 0, 
"n - 'basic_streambuf<char,char_traits<char> >::pos_type' 0 - pos i - 'ios_base::openmode' 0 'std::ios_base::in' -", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~izstream", 1005, G__MCint_210_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncChecksum(void) {
   /* Checksum */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_Checksum));
   G__memfunc_setup("reset",547,G__MCint_211_0_1, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Checksum",819,G__MCint_211_0_2, 105, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Checksum",819,G__MCint_211_0_3, 105, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 0, 1, 1, 1, 0, "u 'Checksum' - 11 - sum", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Checksum",819,G__MCint_211_0_4, 105, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 0, 1, 1, 1, 0, "k - 'uint64_t' 0 - v", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("val",323,G__MCint_211_0_5, 104, -1, G__defined_typename("uint32_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("valid",528,G__MCint_211_0_6, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HandleCarryBits",1503,G__MCint_211_0_7, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__MCint_211_0_8, 117, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 1, 1, 1, 1, 0, "u 'Checksum' - 11 - sum", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+",919,G__MCint_211_0_9, 117, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 0, 1, 1, 1, 8, "u 'Checksum' - 0 - sum", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("add",297,G__MCint_211_0_10, 103, -1, -1, 0, 3, 1, 1, 0, 
"C - - 10 - buf k - 'size_t' 0 - len "
"g - - 0 'true' big_endian", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("addLoopSwapping",1548,G__MCint_211_0_11, 121, -1, -1, 0, 3, 1, 1, 0, 
"R - 'uint16_t' 10 - sbuf R - 'uint16_t' 10 - end "
"H - 'uint32_t' 0 - hilo", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("addLoop",707,G__MCint_211_0_12, 121, -1, -1, 0, 3, 1, 1, 0, 
"R - 'uint16_t' 10 - sbuf R - 'uint16_t' 10 - end "
"H - 'uint32_t' 0 - hilo", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("add",297,G__MCint_211_0_13, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<char,allocator<char> >' 'vector<char>' 11 - v g - - 0 'true' big_endian", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("str",345,G__MCint_211_0_14, 117, G__get_linked_tagnum(&G__MCintLN_string), -1, 0, 1, 1, 1, 8, "g - - 0 'true' complm", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Checksum", 945, G__MCint_211_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_211_0_16, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 1, 1, 1, 1, 0, "u 'Checksum' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncfits(void) {
   /* fits */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_fits));
   G__memfunc_setup("Exception",943,G__MCint_216_0_1, 121, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - txt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadBlock",871,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 1, 1, 2, 0, "u 'vector<string,allocator<string> >' 'vector<std::string>' 1 - vec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Compile",713,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MCintLN_string), -1, 0, 2, 1, 2, 8, 
"u 'string' - 11 - key s - 'int16_t' 0 '-1' i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Constructor",1190,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 4, 1, 2, 0, 
"u 'string' - 11 - fname u 'string' - 0 '\"\"' fout "
"u 'string' - 11 '\"\"' tableName g - - 0 'false' force", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("fits",438,G__MCint_216_0_5, 105, G__get_linked_tagnum(&G__MCintLN_fits), -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - fname u 'string' - 11 '\"\"' tableName "
"g - - 0 'false' force", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("fits",438,G__MCint_216_0_6, 105, G__get_linked_tagnum(&G__MCintLN_fits), -1, 0, 4, 1, 1, 0, 
"u 'string' - 11 - fname u 'string' - 11 - fout "
"u 'string' - 11 - tableName g - - 0 'false' force", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("fits",438,G__MCint_216_0_7, 105, G__get_linked_tagnum(&G__MCintLN_fits), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("StageRow",812,G__MCint_216_0_8, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'size_t' 0 - row C - - 0 - dest", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteRowToCopyFile",1825,G__MCint_216_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'size_t' 0 - row", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ZeroBufferForChecksum",2132,G__MCint_216_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<char,allocator<char> >' 'vector<char>' 1 - vec k - 'uint64_t' 10 '0' extraZeros", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadRow",692,G__MCint_216_0_11, 98, -1, G__defined_typename("uint8_t"), 0, 1, 1, 1, 0, "k - 'size_t' 0 - row", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MoveColumnDataToUserSpace",2509,G__MCint_216_0_12, 121, -1, -1, 0, 3, 1, 1, 0, 
"C - - 0 - dest C - - 10 - src "
"u 'fits::Table::Column' - 11 - c", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetRow",600,G__MCint_216_0_13, 103, -1, -1, 0, 2, 1, 1, 0, 
"k - 'size_t' 0 - row g - - 0 'true' check", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetNextRow",1015,G__MCint_216_0_14, 103, -1, -1, 0, 1, 1, 1, 0, "g - - 0 'true' check", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SkipNextRow",1134,G__MCint_216_0_15, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Compare",711,G__MCint_216_0_16, 103, -1, -1, 0, 2, 3, 1, 0, 
"u 'pair<void*,fits::Table::Column>' 'fits::Address' 11 - p1 u 'pair<void*,fits::Table::Column>' 'fits::Address' 11 - p2", (char*)NULL, (void*) G__func2void( (bool (*)(const fits::Address&, const fits::Address&))(&fits::Compare) ), 0);
   G__memfunc_setup("EnableAddressExceptions",2351,G__MCint_216_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 'true' b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DisableAddressExceptions",2460,G__MCint_216_0_18, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPtrAddress",1320,G__MCint_216_0_19, 89, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPtrAddress",1320,G__MCint_216_0_20, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name Y - - 0 - ptr "
"k - 'size_t' 0 '0' cnt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasKey",581,G__MCint_216_0_21, 103, -1, -1, 0, 1, 1, 1, 8, "u 'string' - 11 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasColumn",906,G__MCint_216_0_22, 103, -1, -1, 0, 1, 1, 1, 8, "u 'string' - 11 - col", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetColumns",1025,G__MCint_216_0_23, 117, G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLTablecLcLColumncOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLTablecLcLColumngRsPgRsPgR), G__defined_typename("fits::Table::Columns"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetSortedColumns",1650,G__MCint_216_0_24, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgR), G__defined_typename("fits::Table::SortedColumns"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetKeys",700,G__MCint_216_0_25, 117, G__get_linked_tagnum(&G__MCintLN_maplEstringcOfitscLcLEntrycOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLEntrygRsPgRsPgR), G__defined_typename("fits::Table::Keys"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetInt",587,G__MCint_216_0_26, 108, -1, G__defined_typename("int64_t"), 0, 1, 1, 1, 8, "u 'string' - 11 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetUInt",672,G__MCint_216_0_27, 107, -1, G__defined_typename("uint64_t"), 0, 1, 1, 1, 8, "u 'string' - 11 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFloat",790,G__MCint_216_0_28, 100, -1, -1, 0, 1, 1, 1, 8, "u 'string' - 11 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetStr",601,G__MCint_216_0_29, 117, G__get_linked_tagnum(&G__MCintLN_string), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetN",366,G__MCint_216_0_30, 107, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "u 'string' - 11 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRow",600,G__MCint_216_0_31, 107, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__MCint_216_0_32, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintKeys",937,G__MCint_216_0_33, 121, -1, -1, 0, 1, 1, 1, 8, "g - - 0 'false' all_keys", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintColumns",1262,G__MCint_216_0_34, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsHeaderOk",959,G__MCint_216_0_35, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsFileOk",758,G__MCint_216_0_36, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IsCompressedFITS",1543,G__MCint_216_0_37, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNumRows",1019,G__MCint_216_0_38, 107, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetBytesPerRow",1414,G__MCint_216_0_39, 107, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetTables",891,G__MCint_216_0_40, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR), G__defined_typename("vector<std::string>"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~fits", 564, G__MCint_216_0_41, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncofits(void) {
   /* ofits */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_ofits));
   G__memfunc_setup("findkey",746,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiterator), -1, 0, 1, 1, 4, 0, "u 'string' - 11 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Set",300,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 4, 1, 4, 0, 
"u 'string' - 11 '\"\"' key g - - 0 'false' delim "
"u 'string' - 11 '\"\"' value u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("findcol",735,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiterator), G__defined_typename("vector<ofits::Table::Column,allocator<ofits::Table::Column> >::const_iterator"), 0, 1, 1, 2, 0, "u 'string' - 11 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ofits",549,G__MCint_256_0_4, 105, G__get_linked_tagnum(&G__MCintLN_ofits), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ofits",549,G__MCint_256_0_5, 105, G__get_linked_tagnum(&G__MCintLN_ofits), -1, 0, 1, 1, 1, 0, "C - - 10 - fname", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("is_open",749,G__MCint_256_0_6, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("is_open",749,G__MCint_256_0_7, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("open",434,G__MCint_256_0_8, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - filename g - - 0 'true' addEXTNAMEKey", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("open",434,G__MCint_256_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - filename g - - 0 'true' addEXTNAMEKey", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AllowCommentsTrimming",2188,G__MCint_256_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - allow", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetKeyComment",1320,G__MCint_256_0_11, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - key u 'string' - 11 - comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CopyKeys",823,G__MCint_256_0_12, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'fits' - 11 - fin g - - 0 'false' update", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRaw",598,G__MCint_256_0_13, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - key u 'string' - 11 - val "
"u 'string' - 11 - comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetBool",696,G__MCint_256_0_14, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - key g - - 0 - b "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddEmpty",792,G__MCint_256_0_15, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - key u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetStr",613,G__MCint_256_0_16, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - key u 'string' - 0 - s "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetInt",599,G__MCint_256_0_17, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - key l - 'int64_t' 0 - i "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFloat",802,G__MCint_256_0_18, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'string' - 11 - key d - - 0 - f "
"i - - 0 - p u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFloat",802,G__MCint_256_0_19, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - key d - - 0 - f "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetHex",593,G__MCint_256_0_20, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - key k - 'uint64_t' 0 - i "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddComment",988,G__MCint_256_0_21, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddHistory",1019,G__MCint_256_0_22, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("End",279,G__MCint_256_0_23, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumn",887,G__MCint_256_0_24, 103, -1, -1, 0, 6, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt c - - 0 - typechar "
"u 'string' - 11 - name u 'string' - 11 - unit "
"u 'string' - 11 '\"\"' comment g - - 0 'true' addHeaderKeys", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AddColumn",887,G__MCint_256_0_25, 103, -1, -1, 0, 7, 1, 1, 0, 
"u 'FITS::Compression' - 11 - - h - 'uint32_t' 0 - cnt "
"c - - 0 - typechar u 'string' - 11 - name "
"u 'string' - 11 - unit u 'string' - 11 '\"\"' comment "
"g - - 0 'true' addHeaderKeys", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AddColumnShort",1415,G__MCint_256_0_26, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnInt",1186,G__MCint_256_0_27, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnLong",1287,G__MCint_256_0_28, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnFloat",1389,G__MCint_256_0_29, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnDouble",1490,G__MCint_256_0_30, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnChar",1269,G__MCint_256_0_31, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnByte",1291,G__MCint_256_0_32, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnBool",1283,G__MCint_256_0_33, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnShort",1415,G__MCint_256_0_34, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnInt",1186,G__MCint_256_0_35, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnLong",1287,G__MCint_256_0_36, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnFloat",1389,G__MCint_256_0_37, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnDouble",1490,G__MCint_256_0_38, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnChar",1269,G__MCint_256_0_39, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnByte",1291,G__MCint_256_0_40, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnBool",1283,G__MCint_256_0_41, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnShort",1415,G__MCint_256_0_42, 103, -1, -1, 0, 5, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnInt",1186,G__MCint_256_0_43, 103, -1, -1, 0, 5, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnLong",1287,G__MCint_256_0_44, 103, -1, -1, 0, 5, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnFloat",1389,G__MCint_256_0_45, 103, -1, -1, 0, 5, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnDouble",1490,G__MCint_256_0_46, 103, -1, -1, 0, 5, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnChar",1269,G__MCint_256_0_47, 103, -1, -1, 0, 5, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnByte",1291,G__MCint_256_0_48, 103, -1, -1, 0, 5, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnBool",1283,G__MCint_256_0_49, 103, -1, -1, 0, 5, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"u 'string' - 11 - name u 'string' - 11 '\"\"' unit "
"u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnShort",1415,G__MCint_256_0_50, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnInt",1186,G__MCint_256_0_51, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnLong",1287,G__MCint_256_0_52, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnFloat",1389,G__MCint_256_0_53, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnDouble",1490,G__MCint_256_0_54, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnChar",1269,G__MCint_256_0_55, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnByte",1291,G__MCint_256_0_56, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddColumnBool",1283,G__MCint_256_0_57, 103, -1, -1, 0, 4, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp u 'string' - 11 - name "
"u 'string' - 11 '\"\"' unit u 'string' - 11 '\"\"' comment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteHeader",1108,G__MCint_256_0_58, 117, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 0, 1, 1, 1, 0, "u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 - fout", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteHeader",1108,G__MCint_256_0_59, 117, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FlushHeader",1099,G__MCint_256_0_60, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteFitsHeader",1514,G__MCint_256_0_61, 117, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteDrsOffsetsTable",2038,G__MCint_256_0_62, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteCatalog",1222,G__MCint_256_0_63, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteTableHeader",1596,G__MCint_256_0_64, 103, -1, -1, 0, 1, 1, 1, 0, "C - - 10 '\"DATA\"' name", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetBytesPerRow",1414,G__MCint_256_0_65, 104, -1, G__defined_typename("uint32_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteRow",835,G__MCint_256_0_66, 103, -1, -1, 0, 3, 1, 1, 0, 
"Y - - 10 - ptr k - 'size_t' 0 - cnt "
"g - - 0 'true' byte_swap", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FlushNumRows",1245,G__MCint_256_0_67, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetNumRows",1019,G__MCint_256_0_68, 107, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AlignTo2880Bytes",1415,G__MCint_256_0_69, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateHeaderChecksum",2015,G__MCint_256_0_70, 117, G__get_linked_tagnum(&G__MCintLN_Checksum), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("close",534,G__MCint_256_0_71, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetChecksumData",1485,G__MCint_256_0_72, 117, G__get_linked_tagnum(&G__MCintLN_pairlEstringcOintgR), G__defined_typename("pair<std::string,int>"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDefaultKeys",1421,G__MCint_256_0_73, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ofits", 675, G__MCint_256_0_74, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHuffman(void) {
   /* Huffman */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_Huffman));
   G__memfunc_setup("numbytes_from_numbits",2283,G__MCint_269_0_1, 107, -1, -1, 0, 1, 3, 1, 0, "k - - 0 - numbits", (char*)NULL, (void*) G__func2void( (unsigned long (*)(unsigned long))(&Huffman::numbytes_from_numbits) ), 0);
   G__memfunc_setup("Encode",590,G__MCint_269_0_2, 103, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 1 - bufout R - 'uint16_t' 10 - bufin "
"k - 'size_t' 0 - bufinlen", (char*)NULL, (void*) G__func2void( (bool (*)(string&, const uint16_t*, size_t))(&Huffman::Encode) ), 0);
   G__memfunc_setup("Decode",580,G__MCint_269_0_3, 108, -1, G__defined_typename("int64_t"), 0, 3, 1, 1, 0, 
"B - 'uint8_t' 10 - bufin k - 'size_t' 0 - bufinlen "
"u 'vector<unsigned short,allocator<unsigned short> >' 'vector<uint16_t>' 1 - pbufout", (char*)NULL, (void*) G__func2void( (int64_t (*)(const uint8_t*, size_t, vector<uint16_t>&))(&Huffman::Decode) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfunczofits(void) {
   /* zofits */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_zofits));
   G__memfunc_setup("DefaultNumThreads",1728,G__MCint_285_0_1, 104, -1, G__defined_typename("uint32_t"), 0, 1, 3, 1, 0, "h - 'uint32_t' 11 '-2' _n", (char*)NULL, (void*) G__func2void( (uint32_t (*)(const uint32_t&))(&zofits::DefaultNumThreads) ), 0);
   G__memfunc_setup("DefaultMaxMemory",1636,G__MCint_285_0_2, 104, -1, G__defined_typename("uint32_t"), 0, 1, 3, 1, 0, "h - 'uint32_t' 11 '0' _n", (char*)NULL, (void*) G__func2void( (uint32_t (*)(const uint32_t&))(&zofits::DefaultMaxMemory) ), 0);
   G__memfunc_setup("DefaultMaxNumTiles",1820,G__MCint_285_0_3, 104, -1, G__defined_typename("uint32_t"), 0, 1, 3, 1, 0, "h - 'uint32_t' 11 '0' _n", (char*)NULL, (void*) G__func2void( (uint32_t (*)(const uint32_t&))(&zofits::DefaultMaxNumTiles) ), 0);
   G__memfunc_setup("DefaultNumRowsPerTile",2133,G__MCint_285_0_4, 104, -1, G__defined_typename("uint32_t"), 0, 1, 3, 1, 0, "h - 'uint32_t' 11 '0' _n", (char*)NULL, (void*) G__func2void( (uint32_t (*)(const uint32_t&))(&zofits::DefaultNumRowsPerTile) ), 0);
   G__memfunc_setup("zofits",671,G__MCint_285_0_5, 105, G__get_linked_tagnum(&G__MCintLN_zofits), -1, 0, 3, 1, 1, 0, 
"h - 'uint32_t' 0 'DefaultMaxNumTiles()' numTiles h - 'uint32_t' 0 'DefaultNumRowsPerTile()' rowPerTile "
"h - 'uint32_t' 0 'DefaultMaxMemory()' maxUsableMem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zofits",671,G__MCint_285_0_6, 105, G__get_linked_tagnum(&G__MCintLN_zofits), -1, 0, 4, 1, 1, 0, 
"C - - 10 - fname h - 'uint32_t' 0 'DefaultMaxNumTiles()' numTiles "
"h - 'uint32_t' 0 'DefaultNumRowsPerTile()' rowPerTile h - 'uint32_t' 0 'DefaultMaxMemory()' maxUsableMem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zofits",671,G__MCint_285_0_7, 105, G__get_linked_tagnum(&G__MCintLN_zofits), -1, 0, 4, 1, 1, 0, 
"u 'string' - 11 - fname h - 'uint32_t' 0 'DefaultMaxNumTiles()' numTiles "
"h - 'uint32_t' 0 'DefaultNumRowsPerTile()' rowPerTile h - 'uint32_t' 0 'DefaultMaxMemory()' maxUsableMem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("InitMemberVariables",1925,G__MCint_285_0_8, 121, -1, -1, 0, 3, 1, 1, 0, 
"h - 'uint32_t' 10 '0' nt h - 'uint32_t' 10 '0' rpt "
"k - 'uint64_t' 10 '0' maxUsableMem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteTableHeader",1596,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 0, "C - - 10 '\"DATA\"' name", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("open",434,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - filename g - - 0 'true' addEXTNAMEKey", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("open",434,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - filename g - - 0 'true' addEXTNAMEKey", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteDrsOffsetsTable",2038,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetBytesPerRow",1414,(G__InterfaceMethod) NULL,104, -1, G__defined_typename("uint32_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteCatalog",1222,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DrsOffsetCalibrate",1815,G__MCint_285_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AddOneCatalogRow",1566,G__MCint_285_0_16, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR), G__defined_typename("zofits::CatalogRow"), 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteRow",835,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"Y - - 10 - ptr k - 'size_t' 0 - cnt "
"g - - 0 'true' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FlushNumRows",1245,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("InitNextCompression",1989,G__MCint_285_0_19, 117, G__get_linked_tagnum(&G__MCintLN_zofitscLcLCompressionTarget), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ShrinkCatalog",1322,G__MCint_285_0_20, 104, -1, G__defined_typename("uint32_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("close",534,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AddColumn",887,(G__InterfaceMethod) NULL,103, -1, -1, 0, 6, 1, 1, 0, 
"h - 'uint32_t' 0 - cnt c - - 0 - typechar "
"u 'string' - 11 - name u 'string' - 11 - unit "
"u 'string' - 11 '\"\"' comment g - - 0 'true' addHeaderKeys", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AddColumn",887,(G__InterfaceMethod) NULL,103, -1, -1, 0, 7, 1, 1, 0, 
"u 'FITS::Compression' - 11 - comp h - 'uint32_t' 0 - cnt "
"c - - 0 - typechar u 'string' - 11 - name "
"u 'string' - 11 - unit u 'string' - 11 '\"\"' comment "
"g - - 0 'true' addHeaderKeys", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetNumThreads",1307,G__MCint_285_0_24, 105, -1, G__defined_typename("int32_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNumThreads",1319,G__MCint_285_0_25, 103, -1, -1, 0, 1, 1, 1, 0, "h - 'uint32_t' 0 - num", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNumTiles",1105,G__MCint_285_0_26, 104, -1, G__defined_typename("uint32_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNumTiles",1117,G__MCint_285_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'uint32_t' 0 - num", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reallocateBuffers",1769,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("writeCompressedDataToDisk",2568,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 2, 1, 2, 0, 
"C - - 0 - src h - 'uint32_t' 10 - sizeToWrite", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CompressBuffer",1446,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 1, 1, 2, 0, "u 'zofits::CompressionTarget' - 11 - target", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteBufferToDisk",1715,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 1, 1, 2, 0, "u 'zofits::WriteTarget' - 11 - target", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("compressBuffer",1478,(G__InterfaceMethod) NULL, 107, -1, G__defined_typename("uint64_t"), 0, 4, 1, 2, 0, 
"C - - 0 - dest C - - 0 - src "
"h - 'uint32_t' 0 - num_rows u 'vector<zofits::CatalogEntry,allocator<zofits::CatalogEntry> >' 'zofits::CatalogRow' 1 - catalog_row", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("copyTransposeTile",1800,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 3, 1, 2, 0, 
"C - - 10 - src C - - 0 - dest "
"h - 'uint32_t' 0 - num_rows", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("compressUNCOMPRESSED",1796,(G__InterfaceMethod) NULL, 104, -1, G__defined_typename("uint32_t"), 0, 3, 1, 2, 0, 
"C - - 0 - dest C - - 10 - src "
"h - 'uint32_t' 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("compressHUFFMAN16",1496,(G__InterfaceMethod) NULL, 104, -1, G__defined_typename("uint32_t"), 0, 5, 1, 2, 0, 
"C - - 0 - dest C - - 10 - src "
"h - 'uint32_t' 0 - numRows h - 'uint32_t' 0 - sizeOfElems "
"h - 'uint32_t' 0 - numRowElems", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("applySMOOTHING",1246,(G__InterfaceMethod) NULL, 104, -1, G__defined_typename("uint32_t"), 0, 2, 1, 2, 0, 
"C - - 0 - data h - 'uint32_t' 0 - numElems", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UnApplySMOOTHING",1409,(G__InterfaceMethod) NULL, 104, -1, G__defined_typename("uint32_t"), 0, 2, 1, 2, 0, 
"C - - 0 - data h - 'uint32_t' 0 - numElems", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~zofits", 797, G__MCint_285_0_38, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDrsCalibrateTime(void) {
   /* DrsCalibrateTime */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime));
   G__memfunc_setup("DrsCalibrateTime",1599,G__MCint_336_0_1, 105, G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DrsCalibrateTime",1599,G__MCint_336_0_2, 105, G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime), -1, 0, 1, 1, 1, 0, "u 'DrsCalibrateTime' - 11 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sum",309,G__MCint_336_0_3, 100, -1, -1, 0, 1, 1, 1, 8, "h - 'uint32_t' 0 - i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("W",87,G__MCint_336_0_4, 100, -1, -1, 0, 1, 1, 1, 8, "h - 'uint32_t' 0 - i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("InitSize",815,G__MCint_336_0_5, 121, -1, -1, 0, 2, 1, 1, 0, 
"r - 'uint16_t' 0 - channels r - 'uint16_t' 0 - samples", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Reset",515,G__MCint_336_0_6, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddT",349,G__MCint_336_0_7, 121, -1, -1, 0, 3, 1, 1, 0, 
"F - - 10 - val S - 'int16_t' 10 - start "
"c - - 0 '0' edge", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FillEmptyBins",1314,G__MCint_336_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetComplete",1113,G__MCint_336_0_9, 117, G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CalcResult",1010,G__MCint_336_0_10, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetResult",927,G__MCint_336_0_11, 117, G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Offset",615,G__MCint_336_0_12, 100, -1, -1, 0, 2, 1, 1, 8, 
"h - 'uint32_t' 0 - ch d - - 0 - pos", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Calib",475,G__MCint_336_0_13, 100, -1, -1, 0, 2, 1, 1, 8, 
"h - 'uint32_t' 0 - ch d - - 0 - pos", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DrsCalibrateTime", 1725, G__MCint_336_0_14, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_336_0_15, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_DrsCalibrateTime), -1, 1, 1, 1, 1, 0, "u 'DrsCalibrateTime' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncfactofits(void) {
   /* factofits */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_factofits));
   G__memfunc_setup("factofits",963,G__MCint_351_0_1, 105, G__get_linked_tagnum(&G__MCintLN_factofits), -1, 0, 3, 1, 1, 0, 
"h - 'uint32_t' 0 'DefaultMaxNumTiles()' numTiles h - 'uint32_t' 0 'DefaultNumRowsPerTile()' rowPerTile "
"h - 'uint32_t' 0 'DefaultMaxMemory()' maxMem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("factofits",963,G__MCint_351_0_2, 105, G__get_linked_tagnum(&G__MCintLN_factofits), -1, 0, 4, 1, 1, 0, 
"C - - 10 - fname h - 'uint32_t' 0 'DefaultMaxNumTiles()' numTiles "
"h - 'uint32_t' 0 'DefaultNumRowsPerTile()' rowPerTile h - 'uint32_t' 0 'DefaultMaxMemory()' maxMem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsOffsetCalibration",1931,G__MCint_351_0_3, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetDrsCalibration",1725,G__MCint_351_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<float,allocator<float> >' 'vector<float>' 11 - calib", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDrsCalibration",1725,G__MCint_351_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<short,allocator<short> >' 'vector<int16_t>' 11 - vec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDrsCalibration",1725,G__MCint_351_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "u 'DrsCalibration' - 11 - drs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteTableHeader",1596,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 0, "C - - 10 '\"DATA\"' name", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteDrsOffsetsTable",2038,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DrsOffsetCalibrate",1815,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "C - - 0 - target_location", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("VerifyCalibrationSize",2168,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 1, 1, 4, 0, "h - 'uint32_t' 0 - size", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~factofits", 1089, G__MCint_351_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfunczfits(void) {
   /* zfits */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_zfits));
   G__memfunc_setup("zfits",560,G__MCint_356_0_1, 105, G__get_linked_tagnum(&G__MCintLN_zfits), -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - fname u 'string' - 11 '\"\"' tableName "
"g - - 0 'false' force", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zfits",560,G__MCint_356_0_2, 105, G__get_linked_tagnum(&G__MCintLN_zfits), -1, 0, 4, 1, 1, 0, 
"u 'string' - 11 - fname u 'string' - 11 - fout "
"u 'string' - 11 - tableName g - - 0 'false' force", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SkipNextRow",1134,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IsFileOk",758,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetNumRows",1019,(G__InterfaceMethod) NULL,107, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetBytesPerRow",1414,(G__InterfaceMethod) NULL,107, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StageRow",812,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 2, 0, 
"k - 'size_t' 0 - row C - - 0 - dest", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("InitCompressionReading",2272,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MoveColumnDataToUserSpace",2509,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 3, 1, 4, 0, 
"C - - 0 - dest C - - 10 - src "
"u 'fits::Table::Column' - 11 - c", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AllocateBuffers",1522,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadCatalog",1079,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("WriteRowToCopyFile",1825,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "k - 'size_t' 0 - row", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ReadBinaryRow",1305,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 2, 1, 4, 0, 
"k - 'size_t' 11 - rowNum C - - 0 - bufferToRead", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UncompressUNCOMPRESSED",1991,(G__InterfaceMethod) NULL, 104, -1, G__defined_typename("uint32_t"), 0, 4, 1, 4, 0, 
"C - - 0 - dest C - - 10 - src "
"h - 'uint32_t' 0 - numElems h - 'uint32_t' 0 - sizeOfElems", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UncompressHUFFMAN16",1691,(G__InterfaceMethod) NULL, 104, -1, G__defined_typename("uint32_t"), 0, 3, 1, 4, 0, 
"C - - 0 - dest C - - 10 - src "
"h - 'uint32_t' 0 - numChunks", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UnApplySMOOTHING",1409,(G__InterfaceMethod) NULL, 104, -1, G__defined_typename("uint32_t"), 0, 2, 1, 4, 0, 
"S - 'int16_t' 0 - data h - 'uint32_t' 0 - numElems", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UncompressBuffer",1673,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 3, 1, 4, 0, 
"u 'vector<unsigned long,allocator<unsigned long> >' 'vector<size_t>' 11 - offsets h - 'uint32_t' 11 - thisRoundNumRows "
"h - 'uint32_t' 10 - offset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CheckIfFileIsConsistent",2291,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "g - - 0 'false' update_catalog", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~zfits", 686, G__MCint_356_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncfactfits(void) {
   /* factfits */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_factfits));
   G__memfunc_setup("factfits",852,G__MCint_374_0_1, 105, G__get_linked_tagnum(&G__MCintLN_factfits), -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - fname u 'string' - 11 '\"\"' tableName "
"g - - 0 'false' force", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("factfits",852,G__MCint_374_0_2, 105, G__get_linked_tagnum(&G__MCintLN_factfits), -1, 0, 4, 1, 1, 0, 
"u 'string' - 11 - fname u 'string' - 11 - fout "
"u 'string' - 11 - tableName g - - 0 'false' force", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetOffsetCalibration",2031,G__MCint_374_0_3, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR), G__defined_typename("vector<int16_t>"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("StageRow",812,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 0, 
"k - 'size_t' 0 - row C - - 0 - dest", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("init",436,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("readDrsCalib",1184,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "u 'string' - 11 - fileName", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~factfits", 978, G__MCint_374_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPixelMapEntry(void) {
   /* PixelMapEntry */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_PixelMapEntry));
   G__memfunc_setup("PixelMapEntry",1330,G__MCint_375_0_1, 105, G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 0, 0, 1, 1, 0, "", "/ Bias supply channel", (void*) NULL, 0);
   G__memfunc_setup("crate",527,G__MCint_375_0_2, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("board",520,G__MCint_375_0_3, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("patch",528,G__MCint_375_0_4, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pixel",546,G__MCint_375_0_5, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hw",223,G__MCint_375_0_6, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("group",557,G__MCint_375_0_7, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("count",553,G__MCint_375_0_8, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hv",222,G__MCint_375_0_9, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__MCint_375_0_10, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MCint_375_0_11, 117, G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const PixelMapEntry& (*)())(&PixelMapEntry::empty) ), 0);
   // automatic copy constructor
   G__memfunc_setup("PixelMapEntry", 1330, G__MCint_375_0_12, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 0, 1, 1, 1, 0, "u 'PixelMapEntry' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PixelMapEntry", 1456, G__MCint_375_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_375_0_14, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 1, 1, 1, 1, 0, "u 'PixelMapEntry' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPixelMap(void) {
   /* PixelMap */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_PixelMap));
   G__memfunc_setup("PixelMap",800,G__MCint_376_0_1, 105, G__get_linked_tagnum(&G__MCintLN_PixelMap), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Read",380,G__MCint_376_0_2, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - fname", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("index",536,G__MCint_376_0_3, 117, G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 1, 1, 1, 1, 9, "i - - 0 - idx", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cbpx",429,G__MCint_376_0_4, 117, G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 1, 1, 1, 1, 9, "i - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cbpx",429,G__MCint_376_0_5, 117, G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 1, 4, 1, 1, 9, 
"i - - 0 - c i - - 0 - b "
"i - - 0 - p i - - 0 - px", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hw",223,G__MCint_376_0_6, 117, G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 1, 1, 1, 1, 9, "i - - 0 - idx", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hv",222,G__MCint_376_0_7, 117, G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 1, 2, 1, 1, 9, 
"i - - 0 - board i - - 0 - channel", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hv",222,G__MCint_376_0_8, 117, G__get_linked_tagnum(&G__MCintLN_PixelMapEntry), -1, 1, 1, 1, 1, 9, "i - - 0 - idx", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PixelMap", 800, G__MCint_376_0_9, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_PixelMap), -1, 0, 1, 1, 1, 0, "u 'PixelMap' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PixelMap", 926, G__MCint_376_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_376_0_11, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_PixelMap), -1, 1, 1, 1, 1, 0, "u 'PixelMap' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncBiasMapEntry(void) {
   /* BiasMapEntry */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_BiasMapEntry));
   G__memfunc_setup("BiasMapEntry",1199,G__MCint_381_0_1, 105, G__get_linked_tagnum(&G__MCintLN_BiasMapEntry), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hv",222,G__MCint_381_0_2, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__MCint_381_0_3, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MCint_381_0_4, 117, G__get_linked_tagnum(&G__MCintLN_BiasMapEntry), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const BiasMapEntry& (*)())(&BiasMapEntry::empty) ), 0);
   // automatic copy constructor
   G__memfunc_setup("BiasMapEntry", 1199, G__MCint_381_0_5, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_BiasMapEntry), -1, 0, 1, 1, 1, 0, "u 'BiasMapEntry' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BiasMapEntry", 1325, G__MCint_381_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_381_0_7, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_BiasMapEntry), -1, 1, 1, 1, 1, 0, "u 'BiasMapEntry' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncBiasMap(void) {
   /* BiasMap */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_BiasMap));
   G__memfunc_setup("BiasMap",669,G__MCint_382_0_1, 105, G__get_linked_tagnum(&G__MCintLN_BiasMap), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Read",380,G__MCint_382_0_2, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - fname", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hv",222,G__MCint_382_0_3, 117, G__get_linked_tagnum(&G__MCintLN_BiasMapEntry), -1, 1, 2, 1, 1, 9, 
"i - - 0 - board i - - 0 - channel", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hv",222,G__MCint_382_0_4, 117, G__get_linked_tagnum(&G__MCintLN_BiasMapEntry), -1, 1, 1, 1, 1, 9, "i - - 0 - idx", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hv",222,G__MCint_382_0_5, 117, G__get_linked_tagnum(&G__MCintLN_BiasMapEntry), -1, 1, 1, 1, 1, 9, "u 'PixelMapEntry' - 11 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Vgapd",498,G__MCint_382_0_6, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR), G__defined_typename("vector<float>"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Voffset",733,G__MCint_382_0_7, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR), G__defined_typename("vector<float>"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Vslope",633,G__MCint_382_0_8, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR), G__defined_typename("vector<float>"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BiasMap", 669, G__MCint_382_0_9, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_BiasMap), -1, 0, 1, 1, 1, 0, "u 'BiasMap' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BiasMap", 795, G__MCint_382_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_382_0_11, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_BiasMap), -1, 1, 1, 1, 1, 0, "u 'BiasMap' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncInterpolator2D(void) {
   /* Interpolator2D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_Interpolator2D));
   G__memfunc_setup("CalculateGrid",1300,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CalculateWeights",1641,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Interpolator2D",1401,G__MCint_387_0_3, 105, G__get_linked_tagnum(&G__MCintLN_Interpolator2D), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Interpolator2D",1401,G__MCint_387_0_4, 105, G__get_linked_tagnum(&G__MCintLN_Interpolator2D), -1, 0, 3, 1, 1, 0, 
"i - - 0 - n D - - 0 - x "
"D - - 0 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Interpolator2D",1401,G__MCint_387_0_5, 105, G__get_linked_tagnum(&G__MCintLN_Interpolator2D), -1, 0, 1, 1, 1, 0, "u 'vector<Interpolator2D::vec,allocator<Interpolator2D::vec> >' 'vector<Interpolator2D::vec>' 11 - v", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getWeights",1051,G__MCint_387_0_6, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR), G__defined_typename("vector<Interpolator2D::weight>"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getInputGrid",1238,G__MCint_387_0_7, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR), G__defined_typename("vector<Interpolator2D::point>"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getOutputGrid",1367,G__MCint_387_0_8, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR), G__defined_typename("vector<Interpolator2D::point>"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadGrid",770,G__MCint_387_0_9, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgR), G__defined_typename("vector<Interpolator2D::vec>"), 0, 1, 3, 1, 0, "u 'string' - 11 - filename", (char*)NULL, (void*) G__func2void( (vector<Interpolator2D::vec> (*)(const string&))(&Interpolator2D::ReadGrid) ), 0);
   G__memfunc_setup("SetInputGrid",1218,G__MCint_387_0_10, 121, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - n D - - 0 - x "
"D - - 0 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetInputGrid",1218,G__MCint_387_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<Interpolator2D::vec,allocator<Interpolator2D::vec> >' 'vector<Interpolator2D::vec>' 11 - v", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadInputGrid",1298,G__MCint_387_0_12, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - filename", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOutputGrid",1347,G__MCint_387_0_13, 103, -1, -1, 0, 3, 1, 1, 0, 
"k - 'size_t' 0 - n D - - 0 - x "
"D - - 0 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOutputGrid",1347,G__MCint_387_0_14, 103, -1, -1, 0, 1, 1, 1, 0, "u 'vector<Interpolator2D::vec,allocator<Interpolator2D::vec> >' 'vector<Interpolator2D::vec>' 11 - v", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReadOutputGrid",1427,G__MCint_387_0_15, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - filename", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Interpolate",1159,G__MCint_387_0_16, 117, G__get_linked_tagnum(&G__MCintLN_vectorlEdoublecOallocatorlEdoublegRsPgR), G__defined_typename("vector<double>"), 0, 1, 1, 1, 8, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - z", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Interpolator2D", 1401, G__MCint_387_0_17, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_Interpolator2D), -1, 0, 1, 1, 1, 0, "u 'Interpolator2D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Interpolator2D", 1527, G__MCint_387_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_387_0_19, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_Interpolator2D), -1, 1, 1, 1, 1, 0, "u 'Interpolator2D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncln_equ_posn(void) {
   /* ln_equ_posn */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_ln_equ_posn));
   // automatic default constructor
   G__memfunc_setup("ln_equ_posn", 1187, G__MCint_415_0_1, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_ln_equ_posn), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ln_equ_posn", 1187, G__MCint_415_0_2, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_ln_equ_posn), -1, 0, 1, 1, 1, 0, "u 'ln_equ_posn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ln_equ_posn", 1313, G__MCint_415_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_415_0_4, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_ln_equ_posn), -1, 1, 1, 1, 1, 0, "u 'ln_equ_posn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncln_hrz_posn(void) {
   /* ln_hrz_posn */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_ln_hrz_posn));
   // automatic default constructor
   G__memfunc_setup("ln_hrz_posn", 1196, G__MCint_416_0_1, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_ln_hrz_posn), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ln_hrz_posn", 1196, G__MCint_416_0_2, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_ln_hrz_posn), -1, 0, 1, 1, 1, 0, "u 'ln_hrz_posn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ln_hrz_posn", 1322, G__MCint_416_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_416_0_4, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_ln_hrz_posn), -1, 1, 1, 1, 1, 0, "u 'ln_hrz_posn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncln_lnlat_posn(void) {
   /* ln_lnlat_posn */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn));
   // automatic default constructor
   G__memfunc_setup("ln_lnlat_posn", 1395, G__MCint_417_0_1, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ln_lnlat_posn", 1395, G__MCint_417_0_2, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn), -1, 0, 1, 1, 1, 0, "u 'ln_lnlat_posn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ln_lnlat_posn", 1521, G__MCint_417_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_417_0_4, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn), -1, 1, 1, 1, 1, 0, "u 'ln_lnlat_posn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncln_rst_time(void) {
   /* ln_rst_time */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_ln_rst_time));
   // automatic default constructor
   G__memfunc_setup("ln_rst_time", 1184, G__MCint_424_0_1, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_ln_rst_time), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ln_rst_time", 1184, G__MCint_424_0_2, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_ln_rst_time), -1, 0, 1, 1, 1, 0, "u 'ln_rst_time' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ln_rst_time", 1310, G__MCint_424_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_424_0_4, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_ln_rst_time), -1, 1, 1, 1, 1, 0, "u 'ln_rst_time' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncNova(void) {
   /* Nova */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_Nova));
   G__memfunc_setup("ORM",238,G__MCint_426_0_1, 117, G__get_linked_tagnum(&G__MCintLN_ln_lnlat_posn), G__defined_typename("Nova::LnLatPosn"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Nova::LnLatPosn& (*)())(&Nova::ORM) ), 0);
   G__memfunc_setup("GetHrzFromEqu",1299,G__MCint_426_0_2, 117, G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn), -1, 0, 3, 1, 1, 0, 
"u 'Nova::EquPosn' - 11 - equ u 'ln_lnlat_posn' 'Nova::LnLatPosn' 11 - obs "
"d - - 0 - jd", (char*)NULL, (void*) G__func2void( (Nova::HrzPosn (*)(const Nova::EquPosn&, const Nova::LnLatPosn&, double))(&Nova::GetHrzFromEqu) ), 0);
   G__memfunc_setup("GetHrzFromEqu",1299,G__MCint_426_0_3, 117, G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn), -1, 0, 2, 1, 1, 0, 
"u 'Nova::EquPosn' - 11 - equ d - - 0 - jd", (char*)NULL, (void*) G__func2void( (Nova::HrzPosn (*)(const Nova::EquPosn&, double))(&Nova::GetHrzFromEqu) ), 0);
   G__memfunc_setup("GetEquFromHrz",1299,G__MCint_426_0_4, 117, G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn), -1, 0, 3, 1, 1, 0, 
"u 'Nova::HrzPosn' - 11 - hrz u 'ln_lnlat_posn' 'Nova::LnLatPosn' 11 - obs "
"d - - 0 - jd", (char*)NULL, (void*) G__func2void( (Nova::EquPosn (*)(const Nova::HrzPosn&, const Nova::LnLatPosn&, double))(&Nova::GetEquFromHrz) ), 0);
   G__memfunc_setup("GetEquFromHrz",1299,G__MCint_426_0_5, 117, G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn), -1, 0, 2, 1, 1, 0, 
"u 'Nova::HrzPosn' - 11 - hrz d - - 0 - jd", (char*)NULL, (void*) G__func2void( (Nova::EquPosn (*)(const Nova::HrzPosn&, double))(&Nova::GetEquFromHrz) ), 0);
   G__memfunc_setup("GetSolarRst",1114,G__MCint_426_0_6, 117, G__get_linked_tagnum(&G__MCintLN_ln_rst_time), G__defined_typename("Nova::RstTime"), 0, 3, 1, 1, 0, 
"d - - 0 - jd u 'ln_lnlat_posn' 'Nova::LnLatPosn' 11 - obs "
"d - - 0 '-0.8333' hrz", (char*)NULL, (void*) G__func2void( (Nova::RstTime (*)(double, const Nova::LnLatPosn&, double))(&Nova::GetSolarRst) ), 0);
   G__memfunc_setup("GetSolarRst",1114,G__MCint_426_0_7, 117, G__get_linked_tagnum(&G__MCintLN_ln_rst_time), G__defined_typename("Nova::RstTime"), 0, 2, 1, 1, 0, 
"d - - 0 - jd d - - 0 '-0.8333' hrz", (char*)NULL, (void*) G__func2void( (Nova::RstTime (*)(double, double))(&Nova::GetSolarRst) ), 0);
   G__memfunc_setup("GetLunarRst",1115,G__MCint_426_0_8, 117, G__get_linked_tagnum(&G__MCintLN_ln_rst_time), G__defined_typename("Nova::RstTime"), 0, 2, 1, 1, 0, 
"d - - 0 - jd u 'ln_lnlat_posn' 'Nova::LnLatPosn' 11 'ORM()' obs", (char*)NULL, (void*) G__func2void( (Nova::RstTime (*)(double, const Nova::LnLatPosn&))(&Nova::GetLunarRst) ), 0);
   G__memfunc_setup("GetSolarEquCoords",1718,G__MCint_426_0_9, 117, G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn), -1, 0, 1, 1, 1, 0, "d - - 0 - jd", (char*)NULL, (void*) G__func2void( (Nova::EquPosn (*)(double))(&Nova::GetSolarEquCoords) ), 0);
   G__memfunc_setup("GetLunarDisk",1197,G__MCint_426_0_10, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - jd", (char*)NULL, (void*) G__func2void( (double (*)(double))(&Nova::GetLunarDisk) ), 0);
   G__memfunc_setup("GetLunarSdiam",1296,G__MCint_426_0_11, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - jd", (char*)NULL, (void*) G__func2void( (double (*)(double))(&Nova::GetLunarSdiam) ), 0);
   G__memfunc_setup("GetLunarPhase",1299,G__MCint_426_0_12, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - jd", (char*)NULL, (void*) G__func2void( (double (*)(double))(&Nova::GetLunarPhase) ), 0);
   G__memfunc_setup("GetLunarEquCoords",1719,G__MCint_426_0_13, 117, G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn), -1, 0, 2, 1, 1, 0, 
"d - - 0 - jd d - - 0 '0' precision", (char*)NULL, (void*) G__func2void( (Nova::EquPosn (*)(double, double))(&Nova::GetLunarEquCoords) ), 0);
   G__memfunc_setup("GetLunarEarthDist",1706,G__MCint_426_0_14, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - jd", (char*)NULL, (void*) G__func2void( (double (*)(double))(&Nova::GetLunarEarthDist) ), 0);
   G__memfunc_setup("GetAngularSeparation",2048,G__MCint_426_0_15, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'Nova::EquPosn' - 11 - p1 u 'Nova::EquPosn' - 11 - p2", (char*)NULL, (void*) G__func2void( (double (*)(const Nova::EquPosn&, const Nova::EquPosn&))(&Nova::GetAngularSeparation) ), 0);
   G__memfunc_setup("GetAngularSeparation",2048,G__MCint_426_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'Nova::HrzPosn' - 11 - h1 u 'Nova::HrzPosn' - 11 - h2", (char*)NULL, (void*) G__func2void( (double (*)(const Nova::HrzPosn&, const Nova::HrzPosn&))(&Nova::GetAngularSeparation) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncNovacLcLZdAzPosn(void) {
   /* Nova::ZdAzPosn */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn));
   G__memfunc_setup("ZdAzPosn",793,G__MCint_427_0_1, 105, G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn), -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' z d - - 0 '0' a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ZdAzPosn",793,G__MCint_427_0_2, 105, G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn), -1, 0, 1, 1, 1, 0, "u 'Nova::HrzPosn' - 11 - hrz", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ZdAzPosn", 793, G__MCint_427_0_3, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn), -1, 0, 1, 1, 1, 0, "u 'Nova::ZdAzPosn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ZdAzPosn", 919, G__MCint_427_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_427_0_5, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_NovacLcLZdAzPosn), -1, 1, 1, 1, 1, 0, "u 'Nova::ZdAzPosn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncNovacLcLRaDecPosn(void) {
   /* Nova::RaDecPosn */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn));
   G__memfunc_setup("RaDecPosn",863,G__MCint_428_0_1, 105, G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn), -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' r d - - 0 '0' d", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RaDecPosn",863,G__MCint_428_0_2, 105, G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn), -1, 0, 1, 1, 1, 0, "u 'Nova::EquPosn' - 11 - equ", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RaDecPosn", 863, G__MCint_428_0_3, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn), -1, 0, 1, 1, 1, 0, "u 'Nova::RaDecPosn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RaDecPosn", 989, G__MCint_428_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_428_0_5, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_NovacLcLRaDecPosn), -1, 1, 1, 1, 1, 0, "u 'Nova::RaDecPosn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncNovacLcLHrzPosn(void) {
   /* Nova::HrzPosn */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn));
   G__memfunc_setup("HrzPosn",724,G__MCint_429_0_1, 105, G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HrzPosn",724,G__MCint_429_0_2, 105, G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn), -1, 0, 1, 1, 1, 0, "u 'Nova::ZdAzPosn' - 11 - za", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("HrzPosn", 724, G__MCint_429_0_3, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn), -1, 0, 1, 1, 1, 0, "u 'Nova::HrzPosn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~HrzPosn", 850, G__MCint_429_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_429_0_5, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_NovacLcLHrzPosn), -1, 1, 1, 1, 1, 0, "u 'Nova::HrzPosn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncNovacLcLEquPosn(void) {
   /* Nova::EquPosn */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn));
   G__memfunc_setup("EquPosn",715,G__MCint_430_0_1, 105, G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EquPosn",715,G__MCint_430_0_2, 105, G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn), -1, 0, 1, 1, 1, 0, "u 'Nova::RaDecPosn' - 11 - rd", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EquPosn", 715, G__MCint_430_0_3, (int) ('i'), G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn), -1, 0, 1, 1, 1, 0, "u 'Nova::EquPosn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EquPosn", 841, G__MCint_430_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MCint_430_0_5, (int) ('u'), G__get_linked_tagnum(&G__MCintLN_NovacLcLEquPosn), -1, 1, 1, 1, 1, 0, "u 'Nova::EquPosn' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFACT(void) {
   /* FACT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MCintLN_FACT));
   G__memfunc_setup("PredictI",788,G__MCint_432_0_1, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'Nova::SolarObjects' - 11 - so u 'Nova::EquPosn' - 11 - srcEqu", (char*)NULL, (void*) G__func2void( (double (*)(const Nova::SolarObjects&, const Nova::EquPosn&))(&FACT::PredictI) ), 0);
   G__memfunc_setup("PredictI",788,G__MCint_432_0_2, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 11 - jd u 'Nova::EquPosn' - 11 - srcEqu", (char*)NULL, (void*) G__func2void( (double (*)(const double&, const Nova::EquPosn&))(&FACT::PredictI) ), 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncMCint() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
}

static void G__cpp_setup_global2() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalMCint() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {
}

static void G__cpp_setup_func20() {
}

static void G__cpp_setup_func21() {
}

static void G__cpp_setup_func22() {
}

static void G__cpp_setup_func23() {
}

static void G__cpp_setup_func24() {
}

static void G__cpp_setup_func25() {
   G__memfunc_setup("ln_get_solar_rst_horizon", 2585, G__MCint__0_2584, 105, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - JD U 'ln_lnlat_posn' - 0 - observer "
"d - - 0 - horizon U 'ln_rst_time' - 0 - rst", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_solar_rst", 1713, G__MCint__0_2585, 105, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - JD U 'ln_lnlat_posn' - 0 - observer "
"U 'ln_rst_time' - 0 - rst", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_solar_equ_coords", 2444, G__MCint__0_2587, 121, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - JD U 'ln_equ_posn' - 0 - position", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_lunar_sdiam", 1895, G__MCint__0_2591, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - JD", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_lunar_rst", 1714, G__MCint__0_2592, 105, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - JD U 'ln_lnlat_posn' - 0 - observer "
"U 'ln_rst_time' - 0 - rst", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_lunar_equ_coords_prec", 2966, G__MCint__0_2594, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - JD U 'ln_equ_posn' - 0 - position "
"d - - 0 - precision", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_lunar_equ_coords", 2445, G__MCint__0_2595, 121, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - JD U 'ln_equ_posn' - 0 - position", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_lunar_phase", 1898, G__MCint__0_2597, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - JD", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_lunar_disk", 1796, G__MCint__0_2598, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - JD", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_lunar_earth_dist", 2432, G__MCint__0_2599, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - JD", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_hrz_from_equ", 2025, G__MCint__0_2613, 121, -1, -1, 0, 4, 1, 1, 0, 
"U 'ln_equ_posn' - 0 - object U 'ln_lnlat_posn' - 0 - observer "
"d - - 0 - JD U 'ln_hrz_posn' - 0 - position", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("ln_get_angular_separation", 2647, G__MCint__0_2624, 100, -1, -1, 0, 2, 1, 1, 0, 
"U 'ln_equ_posn' - 0 - posn1 U 'ln_equ_posn' - 0 - posn2", (char*) NULL
, (void*) NULL, 0);

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcMCint() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
  G__cpp_setup_func20();
  G__cpp_setup_func21();
  G__cpp_setup_func22();
  G__cpp_setup_func23();
  G__cpp_setup_func24();
  G__cpp_setup_func25();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__MCintLN_ios_base = { "ios_base" , 99 , -1 };
G__linked_taginfo G__MCintLN_basic_istreamlEcharcOchar_traitslEchargRsPgR = { "basic_istream<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR = { "basic_ios<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_basic_streambuflEcharcOchar_traitslEchargRsPgR = { "basic_streambuf<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR = { "basic_ostream<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_basic_filebuflEcharcOchar_traitslEchargRsPgR = { "basic_filebuf<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_basic_ofstreamlEcharcOchar_traitslEchargRsPgR = { "basic_ofstream<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_FITS = { "FITS" , 110 , -1 };
G__linked_taginfo G__MCintLN_FITScLcLCompressionProcess_t = { "FITS::CompressionProcess_t" , 101 , -1 };
G__linked_taginfo G__MCintLN_FITScLcLRowOrdering_t = { "FITS::RowOrdering_t" , 101 , -1 };
G__linked_taginfo G__MCintLN_FITScLcLBlockHeader = { "FITS::BlockHeader" , 115 , -1 };
G__linked_taginfo G__MCintLN_FITScLcLCompression = { "FITS::Compression" , 115 , -1 };
G__linked_taginfo G__MCintLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR = { "vector<unsigned short,allocator<unsigned short> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<unsigned short,allocator<unsigned short> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "vector<unsigned int,allocator<unsigned int> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<unsigned int,allocator<unsigned int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlETStringcOallocatorlETStringgRsPgR = { "vector<TString,allocator<TString> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TString,allocator<TString> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_izstream = { "izstream" , 99 , -1 };
G__linked_taginfo G__MCintLN_Checksum = { "Checksum" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR = { "vector<char,allocator<char> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEcharcOallocatorlEchargRsPgRcLcLiteratorgR = { "reverse_iterator<vector<char,allocator<char> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_fits = { "fits" , 99 , -1 };
G__linked_taginfo G__MCintLN_fitscLcLCompression_t = { "fits::Compression_t" , 101 , -1 };
G__linked_taginfo G__MCintLN_fitscLcLfitsstate = { "fits::fitsstate" , 101 , -1 };
G__linked_taginfo G__MCintLN_fitscLcLTable = { "fits::Table" , 115 , -1 };
G__linked_taginfo G__MCintLN_fitscLcLTablecLcLColumn = { "fits::Table::Column" , 115 , -1 };
G__linked_taginfo G__MCintLN_maplEstringcOfitscLcLEntrycOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLEntrygRsPgRsPgR = { "map<string,fits::Entry,less<string>,allocator<pair<const string,fits::Entry> > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_maplEstringcOfitscLcLTablecLcLColumncOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLTablecLcLColumngRsPgRsPgR = { "map<string,fits::Table::Column,less<string>,allocator<pair<const string,fits::Table::Column> > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgR = { "vector<fits::Table::Column,allocator<fits::Table::Column> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgRcLcLiteratorgR = { "reverse_iterator<vector<fits::Table::Column,allocator<fits::Table::Column> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR = { "vector<string,allocator<string> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<string,allocator<string> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_pairlEvoidmUcOfitscLcLTablecLcLColumngR = { "pair<void*,fits::Table::Column>" , 115 , -1 };
G__linked_taginfo G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR = { "vector<pair<void*,fits::Table::Column>,allocator<pair<void*,fits::Table::Column> > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<void*,fits::Table::Column>,allocator<pair<void*,fits::Table::Column> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_unordered_maplEstringcOvoidmUgR = { "unordered_map<string,void*>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR = { "vector<vector<char,allocator<char> >,allocator<vector<char,allocator<char> > > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<char,allocator<char> >,allocator<vector<char,allocator<char> > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_ofits = { "ofits" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgR = { "vector<ofits::Key,allocator<ofits::Key> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiterator = { "vector<ofits::Key,allocator<ofits::Key> >::iterator" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ofits::Key,allocator<ofits::Key> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_ofitscLcLTable = { "ofits::Table" , 115 , -1 };
G__linked_taginfo G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgR = { "vector<ofits::Table::Column,allocator<ofits::Table::Column> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiterator = { "vector<ofits::Table::Column,allocator<ofits::Table::Column> >::iterator" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ofits::Table::Column,allocator<ofits::Table::Column> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_pairlEstringcOintgR = { "pair<string,int>" , 115 , -1 };
G__linked_taginfo G__MCintLN_Huffman = { "Huffman" , 110 , -1 };
G__linked_taginfo G__MCintLN_MemoryManager = { "MemoryManager" , 99 , -1 };
G__linked_taginfo G__MCintLN_shared_ptrlEchargR = { "shared_ptr<char>" , 99 , -1 };
G__linked_taginfo G__MCintLN_forward_listlEshared_ptrlEchargRsPgR = { "forward_list<shared_ptr<char> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_zofits = { "zofits" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR = { "vector<zofits::CatalogEntry,allocator<zofits::CatalogEntry> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcLcLiteratorgR = { "reverse_iterator<vector<zofits::CatalogEntry,allocator<zofits::CatalogEntry> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_listlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcOallocatorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRsPgRsPgR = { "list<vector<zofits::CatalogEntry,allocator<zofits::CatalogEntry> >,allocator<vector<zofits::CatalogEntry,allocator<zofits::CatalogEntry> > > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_zofitscLcLWriteTarget = { "zofits::WriteTarget" , 115 , -1 };
G__linked_taginfo G__MCintLN_zofitscLcLCompressionTarget = { "zofits::CompressionTarget" , 115 , -1 };
G__linked_taginfo G__MCintLN_listlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgR = { "list<zofits::CompressionTarget,allocator<zofits::CompressionTarget> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_QueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgR = { "Queue<zofits::CompressionTarget,list<zofits::CompressionTarget,allocator<zofits::CompressionTarget> > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgR = { "vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget,allocator<zofits::CompressionTarget> > >,allocator<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget,allocator<zofits::CompressionTarget> > > > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget,allocator<zofits::CompressionTarget> > >,allocator<Queue<zofits::CompressionTarget,list<zofits::CompressionTarget,allocator<zofits::CompressionTarget> > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_zofitscLcLQueueMinlEzofitscLcLWriteTargetgR = { "zofits::QueueMin<zofits::WriteTarget>" , 115 , -1 };
G__linked_taginfo G__MCintLN_listlEzofitscLcLWriteTargetcOallocatorlEzofitscLcLWriteTargetgRsPgR = { "list<zofits::WriteTarget,allocator<zofits::WriteTarget> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_QueuelEzofitscLcLWriteTargetcOzofitscLcLQueueMinlEzofitscLcLWriteTargetgRsPgR = { "Queue<zofits::WriteTarget,zofits::QueueMin<zofits::WriteTarget> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgR = { "vector<zofits::CompressedColumn,allocator<zofits::CompressedColumn> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgRcLcLiteratorgR = { "reverse_iterator<vector<zofits::CompressedColumn,allocator<zofits::CompressedColumn> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlElongcOallocatorlElonggRsPgR = { "vector<long,allocator<long> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlElongcOallocatorlElonggRsPgRcLcLiteratorgR = { "reverse_iterator<vector<long,allocator<long> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgR = { "vector<DrsCalibrate::Step,allocator<DrsCalibrate::Step> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<DrsCalibrate::Step,allocator<DrsCalibrate::Step> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<double,allocator<double> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_pairlEvectorlEdoublecOallocatorlEdoublegRsPgRcOvectorlEdoublecOallocatorlEdoublegRsPgRsPgR = { "pair<vector<double,allocator<double> >,vector<double,allocator<double> > >" , 115 , -1 };
G__linked_taginfo G__MCintLN_DrsCalibrateTime = { "DrsCalibrateTime" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR = { "vector<pair<double,double>,allocator<pair<double,double> > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<double,double>,allocator<pair<double,double> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_DrsCalibration = { "DrsCalibration" , 115 , -1 };
G__linked_taginfo G__MCintLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<int,allocator<int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR = { "vector<float,allocator<float> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEfloatcOallocatorlEfloatgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<float,allocator<float> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_factofits = { "factofits" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR = { "vector<short,allocator<short> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEshortcOallocatorlEshortgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<short,allocator<short> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_zfits = { "zfits" , 99 , -1 };
G__linked_taginfo G__MCintLN_pairlElongcOlonggR = { "pair<long,long>" , 115 , -1 };
G__linked_taginfo G__MCintLN_vectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgR = { "vector<pair<long,long>,allocator<pair<long,long> > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<long,long>,allocator<pair<long,long> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR = { "vector<vector<pair<long,long>,allocator<pair<long,long> > >,allocator<vector<pair<long,long>,allocator<pair<long,long> > > > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<pair<long,long>,allocator<pair<long,long> > >,allocator<vector<pair<long,long>,allocator<pair<long,long> > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgR = { "vector<unsigned long,allocator<unsigned long> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcLcLiteratorgR = { "reverse_iterator<vector<unsigned long,allocator<unsigned long> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR = { "vector<vector<unsigned long,allocator<unsigned long> >,allocator<vector<unsigned long,allocator<unsigned long> > > >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<unsigned long,allocator<unsigned long> >,allocator<vector<unsigned long,allocator<unsigned long> > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_factfits = { "factfits" , 99 , -1 };
G__linked_taginfo G__MCintLN_PixelMapEntry = { "PixelMapEntry" , 115 , -1 };
G__linked_taginfo G__MCintLN_PixelMap = { "PixelMap" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgR = { "vector<PixelMapEntry,allocator<PixelMapEntry> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgRcLcLiteratorgR = { "reverse_iterator<vector<PixelMapEntry,allocator<PixelMapEntry> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_BiasMapEntry = { "BiasMapEntry" , 115 , -1 };
G__linked_taginfo G__MCintLN_BiasMap = { "BiasMap" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgR = { "vector<BiasMapEntry,allocator<BiasMapEntry> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgRcLcLiteratorgR = { "reverse_iterator<vector<BiasMapEntry,allocator<BiasMapEntry> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_Interpolator2D = { "Interpolator2D" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR = { "vector<Interpolator2D::point,allocator<Interpolator2D::point> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Interpolator2D::point,allocator<Interpolator2D::point> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgR = { "vector<Interpolator2D::circle,allocator<Interpolator2D::circle> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Interpolator2D::circle,allocator<Interpolator2D::circle> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR = { "vector<Interpolator2D::weight,allocator<Interpolator2D::weight> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Interpolator2D::weight,allocator<Interpolator2D::weight> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_vectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgR = { "vector<Interpolator2D::vec,allocator<Interpolator2D::vec> >" , 99 , -1 };
G__linked_taginfo G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Interpolator2D::vec,allocator<Interpolator2D::vec> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MCintLN_ln_equ_posn = { "ln_equ_posn" , 115 , -1 };
G__linked_taginfo G__MCintLN_ln_hrz_posn = { "ln_hrz_posn" , 115 , -1 };
G__linked_taginfo G__MCintLN_ln_lnlat_posn = { "ln_lnlat_posn" , 115 , -1 };
G__linked_taginfo G__MCintLN_ln_rst_time = { "ln_rst_time" , 115 , -1 };
G__linked_taginfo G__MCintLN_Nova = { "Nova" , 110 , -1 };
G__linked_taginfo G__MCintLN_NovacLcLZdAzPosn = { "Nova::ZdAzPosn" , 115 , -1 };
G__linked_taginfo G__MCintLN_NovacLcLRaDecPosn = { "Nova::RaDecPosn" , 115 , -1 };
G__linked_taginfo G__MCintLN_NovacLcLHrzPosn = { "Nova::HrzPosn" , 115 , -1 };
G__linked_taginfo G__MCintLN_NovacLcLEquPosn = { "Nova::EquPosn" , 115 , -1 };
G__linked_taginfo G__MCintLN_NovacLcLSolarObjects = { "Nova::SolarObjects" , 115 , -1 };
G__linked_taginfo G__MCintLN_FACT = { "FACT" , 110 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableMCint() {
  G__MCintLN_ios_base.tagnum = -1 ;
  G__MCintLN_basic_istreamlEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__MCintLN_basic_streambuflEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__MCintLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__MCintLN_basic_filebuflEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__MCintLN_basic_ofstreamlEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__MCintLN_string.tagnum = -1 ;
  G__MCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_FITS.tagnum = -1 ;
  G__MCintLN_FITScLcLCompressionProcess_t.tagnum = -1 ;
  G__MCintLN_FITScLcLRowOrdering_t.tagnum = -1 ;
  G__MCintLN_FITScLcLBlockHeader.tagnum = -1 ;
  G__MCintLN_FITScLcLCompression.tagnum = -1 ;
  G__MCintLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlETStringcOallocatorlETStringgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_izstream.tagnum = -1 ;
  G__MCintLN_Checksum.tagnum = -1 ;
  G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEcharcOallocatorlEchargRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_fits.tagnum = -1 ;
  G__MCintLN_fitscLcLCompression_t.tagnum = -1 ;
  G__MCintLN_fitscLcLfitsstate.tagnum = -1 ;
  G__MCintLN_fitscLcLTable.tagnum = -1 ;
  G__MCintLN_fitscLcLTablecLcLColumn.tagnum = -1 ;
  G__MCintLN_maplEstringcOfitscLcLEntrycOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLEntrygRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_maplEstringcOfitscLcLTablecLcLColumncOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLTablecLcLColumngRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_vectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_pairlEvoidmUcOfitscLcLTablecLcLColumngR.tagnum = -1 ;
  G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_unordered_maplEstringcOvoidmUgR.tagnum = -1 ;
  G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_ofits.tagnum = -1 ;
  G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgR.tagnum = -1 ;
  G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiterator.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_ofitscLcLTable.tagnum = -1 ;
  G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgR.tagnum = -1 ;
  G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiterator.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_pairlEstringcOintgR.tagnum = -1 ;
  G__MCintLN_Huffman.tagnum = -1 ;
  G__MCintLN_MemoryManager.tagnum = -1 ;
  G__MCintLN_shared_ptrlEchargR.tagnum = -1 ;
  G__MCintLN_forward_listlEshared_ptrlEchargRsPgR.tagnum = -1 ;
  G__MCintLN_zofits.tagnum = -1 ;
  G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_listlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcOallocatorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_zofitscLcLWriteTarget.tagnum = -1 ;
  G__MCintLN_zofitscLcLCompressionTarget.tagnum = -1 ;
  G__MCintLN_listlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgR.tagnum = -1 ;
  G__MCintLN_QueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_zofitscLcLQueueMinlEzofitscLcLWriteTargetgR.tagnum = -1 ;
  G__MCintLN_listlEzofitscLcLWriteTargetcOallocatorlEzofitscLcLWriteTargetgRsPgR.tagnum = -1 ;
  G__MCintLN_QueuelEzofitscLcLWriteTargetcOzofitscLcLQueueMinlEzofitscLcLWriteTargetgRsPgR.tagnum = -1 ;
  G__MCintLN_vectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlElongcOallocatorlElonggRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlElongcOallocatorlElonggRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_pairlEvectorlEdoublecOallocatorlEdoublegRsPgRcOvectorlEdoublecOallocatorlEdoublegRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_DrsCalibrateTime.tagnum = -1 ;
  G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_DrsCalibration.tagnum = -1 ;
  G__MCintLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEfloatcOallocatorlEfloatgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_factofits.tagnum = -1 ;
  G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEshortcOallocatorlEshortgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_zfits.tagnum = -1 ;
  G__MCintLN_pairlElongcOlonggR.tagnum = -1 ;
  G__MCintLN_vectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_factfits.tagnum = -1 ;
  G__MCintLN_PixelMapEntry.tagnum = -1 ;
  G__MCintLN_PixelMap.tagnum = -1 ;
  G__MCintLN_vectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_BiasMapEntry.tagnum = -1 ;
  G__MCintLN_BiasMap.tagnum = -1 ;
  G__MCintLN_vectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_Interpolator2D.tagnum = -1 ;
  G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_vectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgR.tagnum = -1 ;
  G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MCintLN_ln_equ_posn.tagnum = -1 ;
  G__MCintLN_ln_hrz_posn.tagnum = -1 ;
  G__MCintLN_ln_lnlat_posn.tagnum = -1 ;
  G__MCintLN_ln_rst_time.tagnum = -1 ;
  G__MCintLN_Nova.tagnum = -1 ;
  G__MCintLN_NovacLcLZdAzPosn.tagnum = -1 ;
  G__MCintLN_NovacLcLRaDecPosn.tagnum = -1 ;
  G__MCintLN_NovacLcLHrzPosn.tagnum = -1 ;
  G__MCintLN_NovacLcLEquPosn.tagnum = -1 ;
  G__MCintLN_NovacLcLSolarObjects.tagnum = -1 ;
  G__MCintLN_FACT.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableMCint() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__MCintLN_ios_base);
   G__get_linked_tagnum_fwd(&G__MCintLN_basic_istreamlEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_basic_ioslEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_basic_streambuflEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_basic_filebuflEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_basic_ofstreamlEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_string);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_FITS),0,-1,262144,(char*)NULL,G__setup_memvarFITS,G__setup_memfuncFITS);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_FITScLcLCompressionProcess_t),sizeof(int),-1,262144,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_FITScLcLRowOrdering_t),sizeof(int),-1,262144,(char*)NULL,NULL,NULL);
   G__get_linked_tagnum_fwd(&G__MCintLN_FITScLcLBlockHeader);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_FITScLcLCompression),sizeof(FITS::Compression),-1,295168,(char*)NULL,G__setup_memvarFITScLcLCompression,G__setup_memfuncFITScLcLCompression);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlETStringcOallocatorlETStringgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_izstream),sizeof(izstream),-1,296192,(char*)NULL,G__setup_memvarizstream,G__setup_memfuncizstream);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_Checksum),sizeof(Checksum),-1,295680,(char*)NULL,G__setup_memvarChecksum,G__setup_memfuncChecksum);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEcharcOallocatorlEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEcharcOallocatorlEchargRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_fits),sizeof(fits),-1,296192,(char*)NULL,G__setup_memvarfits,G__setup_memfuncfits);
   G__get_linked_tagnum_fwd(&G__MCintLN_fitscLcLCompression_t);
   G__get_linked_tagnum_fwd(&G__MCintLN_fitscLcLfitsstate);
   G__get_linked_tagnum_fwd(&G__MCintLN_fitscLcLTable);
   G__get_linked_tagnum_fwd(&G__MCintLN_fitscLcLTablecLcLColumn);
   G__get_linked_tagnum_fwd(&G__MCintLN_maplEstringcOfitscLcLEntrycOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLEntrygRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_maplEstringcOfitscLcLTablecLcLColumncOlesslEstringgRcOallocatorlEpairlEconstsPstringcOfitscLcLTablecLcLColumngRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEfitscLcLTablecLcLColumncOallocatorlEfitscLcLTablecLcLColumngRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEstringcOallocatorlEstringgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_pairlEvoidmUcOfitscLcLTablecLcLColumngR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRcOallocatorlEpairlEvoidmUcOfitscLcLTablecLcLColumngRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_unordered_maplEstringcOvoidmUgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEcharcOallocatorlEchargRsPgRcOallocatorlEvectorlEcharcOallocatorlEchargRsPgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_ofits),sizeof(ofits),-1,296192,(char*)NULL,G__setup_memvarofits,G__setup_memfuncofits);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEofitscLcLKeycOallocatorlEofitscLcLKeygRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_ofitscLcLTable);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEofitscLcLTablecLcLColumncOallocatorlEofitscLcLTablecLcLColumngRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_pairlEstringcOintgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_Huffman),0,-1,262144,(char*)NULL,G__setup_memvarHuffman,G__setup_memfuncHuffman);
   G__get_linked_tagnum_fwd(&G__MCintLN_MemoryManager);
   G__get_linked_tagnum_fwd(&G__MCintLN_shared_ptrlEchargR);
   G__get_linked_tagnum_fwd(&G__MCintLN_forward_listlEshared_ptrlEchargRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_zofits),sizeof(zofits),-1,295168,(char*)NULL,G__setup_memvarzofits,G__setup_memfunczofits);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_listlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRcOallocatorlEvectorlEzofitscLcLCatalogEntrycOallocatorlEzofitscLcLCatalogEntrygRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_zofitscLcLWriteTarget);
   G__get_linked_tagnum_fwd(&G__MCintLN_zofitscLcLCompressionTarget);
   G__get_linked_tagnum_fwd(&G__MCintLN_listlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_QueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRcOallocatorlEQueuelEzofitscLcLCompressionTargetcOlistlEzofitscLcLCompressionTargetcOallocatorlEzofitscLcLCompressionTargetgRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_zofitscLcLQueueMinlEzofitscLcLWriteTargetgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_listlEzofitscLcLWriteTargetcOallocatorlEzofitscLcLWriteTargetgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_QueuelEzofitscLcLWriteTargetcOzofitscLcLQueueMinlEzofitscLcLWriteTargetgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEzofitscLcLCompressedColumncOallocatorlEzofitscLcLCompressedColumngRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlElongcOallocatorlElonggRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlElongcOallocatorlElonggRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEDrsCalibratecLcLStepcOallocatorlEDrsCalibratecLcLStepgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_pairlEvectorlEdoublecOallocatorlEdoublegRsPgRcOvectorlEdoublecOallocatorlEdoublegRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_DrsCalibrateTime),sizeof(DrsCalibrateTime),-1,263936,(char*)NULL,G__setup_memvarDrsCalibrateTime,G__setup_memfuncDrsCalibrateTime);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEpairlEdoublecOdoublegRcOallocatorlEpairlEdoublecOdoublegRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_DrsCalibration);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEintcOallocatorlEintgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEfloatcOallocatorlEfloatgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEfloatcOallocatorlEfloatgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_factofits),sizeof(factofits),-1,296192,(char*)NULL,G__setup_memvarfactofits,G__setup_memfuncfactofits);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEshortcOallocatorlEshortgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEshortcOallocatorlEshortgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_zfits),sizeof(zfits),-1,294912,(char*)NULL,G__setup_memvarzfits,G__setup_memfunczfits);
   G__get_linked_tagnum_fwd(&G__MCintLN_pairlElongcOlonggR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRcOallocatorlEvectorlEpairlElongcOlonggRcOallocatorlEpairlElongcOlonggRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRcOallocatorlEvectorlEunsignedsPlongcOallocatorlEunsignedsPlonggRsPgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_factfits),sizeof(factfits),-1,294912,(char*)NULL,G__setup_memvarfactfits,G__setup_memfuncfactfits);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_PixelMapEntry),sizeof(PixelMapEntry),-1,262400,(char*)NULL,G__setup_memvarPixelMapEntry,G__setup_memfuncPixelMapEntry);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_PixelMap),sizeof(PixelMap),-1,295168,(char*)NULL,G__setup_memvarPixelMap,G__setup_memfuncPixelMap);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEPixelMapEntrycOallocatorlEPixelMapEntrygRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_BiasMapEntry),sizeof(BiasMapEntry),-1,262400,(char*)NULL,G__setup_memvarBiasMapEntry,G__setup_memfuncBiasMapEntry);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_BiasMap),sizeof(BiasMap),-1,295168,(char*)NULL,G__setup_memvarBiasMap,G__setup_memfuncBiasMap);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEBiasMapEntrycOallocatorlEBiasMapEntrygRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_Interpolator2D),sizeof(Interpolator2D),-1,295168,(char*)NULL,G__setup_memvarInterpolator2D,G__setup_memfuncInterpolator2D);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLpointcOallocatorlEInterpolator2DcLcLpointgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLcirclecOallocatorlEInterpolator2DcLcLcirclegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLweightcOallocatorlEInterpolator2DcLcLweightgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_vectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgR);
   G__get_linked_tagnum_fwd(&G__MCintLN_reverse_iteratorlEvectorlEInterpolator2DcLcLveccOallocatorlEInterpolator2DcLcLvecgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_ln_equ_posn),sizeof(ln_equ_posn),-1,0,(char*)NULL,G__setup_memvarln_equ_posn,G__setup_memfuncln_equ_posn);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_ln_hrz_posn),sizeof(ln_hrz_posn),-1,0,(char*)NULL,G__setup_memvarln_hrz_posn,G__setup_memfuncln_hrz_posn);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_ln_lnlat_posn),sizeof(ln_lnlat_posn),-1,0,(char*)NULL,G__setup_memvarln_lnlat_posn,G__setup_memfuncln_lnlat_posn);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_ln_rst_time),sizeof(ln_rst_time),-1,0,(char*)NULL,G__setup_memvarln_rst_time,G__setup_memfuncln_rst_time);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_Nova),0,-1,0,(char*)NULL,G__setup_memvarNova,G__setup_memfuncNova);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_NovacLcLZdAzPosn),sizeof(Nova::ZdAzPosn),-1,33024,(char*)NULL,G__setup_memvarNovacLcLZdAzPosn,G__setup_memfuncNovacLcLZdAzPosn);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_NovacLcLRaDecPosn),sizeof(Nova::RaDecPosn),-1,33024,(char*)NULL,G__setup_memvarNovacLcLRaDecPosn,G__setup_memfuncNovacLcLRaDecPosn);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_NovacLcLHrzPosn),sizeof(Nova::HrzPosn),-1,33024,(char*)NULL,G__setup_memvarNovacLcLHrzPosn,G__setup_memfuncNovacLcLHrzPosn);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_NovacLcLEquPosn),sizeof(Nova::EquPosn),-1,33024,(char*)NULL,G__setup_memvarNovacLcLEquPosn,G__setup_memfuncNovacLcLEquPosn);
   G__get_linked_tagnum_fwd(&G__MCintLN_NovacLcLSolarObjects);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MCintLN_FACT),0,-1,262144,(char*)NULL,G__setup_memvarFACT,G__setup_memfuncFACT);
}
extern "C" void G__cpp_setupMCint(void) {
  G__check_setup_version(30051515,"G__cpp_setupMCint()");
  G__set_cpp_environmentMCint();
  G__cpp_setup_tagtableMCint();

  G__cpp_setup_inheritanceMCint();

  G__cpp_setup_typetableMCint();

  G__cpp_setup_memvarMCint();

  G__cpp_setup_memfuncMCint();
  G__cpp_setup_globalMCint();
  G__cpp_setup_funcMCint();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncMCint();
  return;
}
class G__cpp_setup_initMCint {
  public:
    G__cpp_setup_initMCint() { G__add_setup_func("MCint",(G__incsetup)(&G__cpp_setupMCint)); G__call_setup_funcs(); }
   ~G__cpp_setup_initMCint() { G__remove_setup_func("MCint"); }
};
G__cpp_setup_initMCint G__cpp_setup_initializerMCint;

